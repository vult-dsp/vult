/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef SYNTH2_H
#define SYNTH2_H

#include "vultin.h"
#include "synth2.tables.h"

typedef struct Synth2_change_type {
   fix16_t pre_x;
} Synth2_change_type;

typedef struct Synth2_bchange_type {
   bool pre_x;
} Synth2_bchange_type;

typedef struct Synth2_edge_type {
   bool pre_x;
} Synth2_edge_type;

typedef struct Synth2_each_type {
   int32_t count;
} Synth2_each_type;

typedef struct Synth2_dcblock_type {
   fix16_t x1;
   fix16_t y1;
} Synth2_dcblock_type;

typedef struct Synth2_smooth_type {
   fix16_t x;
} Synth2_smooth_type;

typedef struct Synth2_lpfilter_type {
   fix16_t pre_x;
} Synth2_lpfilter_type;

typedef struct Synth2_osc_type {
   Synth2_change_type inst_177e5;
   Synth2_dcblock_type inst_24fe5;
   fix16_t m;
   fix16_t output;
   fix16_t phase;
   fix16_t rate;
   fix16_t state_pulse;
   fix16_t state_saw;
   fix16_t state_triang;
} Synth2_osc_type;

typedef struct Synth2_svf_step_type {
   fix16_t dband;
   fix16_t dlow;
} Synth2_svf_step_type;

typedef struct Synth2_svf_type {
   fix16_t g;
   Synth2_change_type inst_177a7;
   Synth2_svf_step_type step;
} Synth2_svf_type;

typedef struct Synth2_lfo_type {
   Synth2_edge_type inst_1445f;
   Synth2_each_type inst_2cb5f;
   fix16_t phase;
} Synth2_lfo_type;

typedef struct Synth2_mono_noteOn_type {
   int32_t count;
   std::array<int32_t, 4> notes;
   int32_t pre;
} Synth2_mono_noteOn_type;

typedef struct Synth2_mono_noteOn_type Synth2_mono_noteOff_type;

typedef struct Synth2_mono_noteOn_type Synth2_mono_isGateOn_type;

typedef struct Synth2_process_type {
   fix16_t amp_s;
   fix16_t cut;
   Synth2_lfo_type inst_15fb7;
   Synth2_osc_type inst_2e5b7;
   Synth2_smooth_type inst_3dfb7;
   Synth2_svf_type inst_4a7b7;
   fix16_t lfo_amt;
   fix16_t lfo_rate;
   Synth2_mono_noteOn_type monoin;
   fix16_t pitch;
   fix16_t pw;
   fix16_t res;
   fix16_t volume;
   fix16_t wave;
} Synth2_process_type;

typedef struct Synth2_process_type Synth2_noteOn_type;

typedef struct Synth2_process_type Synth2_noteOff_type;

typedef struct Synth2_process_type Synth2_controlChange_type;

typedef struct Synth2_process_type Synth2_default_type;

static_inline void Synth2_change_type_init(Synth2_change_type& _ctx) {
   _ctx.pre_x = 0x0 /* 0.000000 */;
}

static_inline void Synth2_bchange_type_init(Synth2_bchange_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Synth2_edge_type_init(Synth2_edge_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Synth2_each_type_init(Synth2_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Synth2_dcblock_type_init(Synth2_dcblock_type& _ctx) {
   _ctx.x1 = 0x0 /* 0.000000 */;
   _ctx.y1 = 0x0 /* 0.000000 */;
}

static_inline void Synth2_smooth_type_init(Synth2_smooth_type& _ctx) {
   _ctx.x = 0x0 /* 0.000000 */;
}

static_inline void Synth2_lpfilter_type_init(Synth2_lpfilter_type& _ctx) {
   _ctx.pre_x = 0x0 /* 0.000000 */;
}

void Synth2_osc_type_init(Synth2_osc_type& _ctx);

static_inline void Synth2_svf_step_type_init(Synth2_svf_step_type& _ctx) {
   _ctx.dband = 0x0 /* 0.000000 */;
   _ctx.dlow = 0x0 /* 0.000000 */;
}

static_inline void Synth2_svf_type_init(Synth2_svf_type& _ctx) {
   _ctx.g = 0x0 /* 0.000000 */;
   Synth2_change_type_init(_ctx.inst_177a7);
   Synth2_svf_step_type_init(_ctx.step);
}

static_inline void Synth2_lfo_type_init(Synth2_lfo_type& _ctx) {
   Synth2_edge_type_init(_ctx.inst_1445f);
   Synth2_each_type_init(_ctx.inst_2cb5f);
   _ctx.phase = 0x0 /* 0.000000 */;
}

void Synth2_mono_noteOn_type_init(Synth2_mono_noteOn_type& _ctx);

static_inline void Synth2_mono_noteOff_type_init(Synth2_mono_noteOff_type& _ctx) {
   Synth2_mono_noteOn_type_init(_ctx);
}

static_inline void Synth2_mono_isGateOn_type_init(Synth2_mono_isGateOn_type& _ctx) {
   Synth2_mono_noteOn_type_init(_ctx);
}

void Synth2_default(Synth2_process_type& _ctx);

void Synth2_process_type_init(Synth2_process_type& _ctx);

static_inline void Synth2_noteOn_type_init(Synth2_noteOn_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_noteOff_type_init(Synth2_noteOff_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_controlChange_type_init(Synth2_controlChange_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_default_type_init(Synth2_default_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline fix16_t Synth2_minFixed() {
   return 0x1 /* 0.000015 */;
}

static_inline bool Synth2_change(Synth2_change_type& _ctx, fix16_t x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_bchange(Synth2_bchange_type& _ctx, bool x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_edge(Synth2_edge_type& _ctx, bool x) {
   bool v = (_ctx.pre_x != x) && (_ctx.pre_x == true);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_each(Synth2_each_type& _ctx, int32_t n) {
   bool ret = _ctx.count == 0;
   _ctx.count = (1 + _ctx.count) % n;
   return ret;
}

static_inline bool Synth2_near_zero(fix16_t x) {
   return fix_abs(x) < 0x51e /* 0.020000 */;
}

static_inline fix16_t Synth2_dcblock(Synth2_dcblock_type& _ctx, fix16_t x0) {
   fix16_t y0 = x0 + (- _ctx.x1) + fix_mul(0xfeb8 /* 0.995000 */, _ctx.y1);
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

static_inline fix16_t Synth2_smooth(Synth2_smooth_type& _ctx, fix16_t input) {
   _ctx.x = fix_mul(0x147 /* 0.005000 */, (input + (- _ctx.x))) + _ctx.x;
   return _ctx.x;
}

static_inline fix16_t Synth2_lpfilter(Synth2_lpfilter_type& _ctx, fix16_t x) {
   fix16_t ret = fix_mul(0x8000 /* 0.500000 */, (x + _ctx.pre_x));
   _ctx.pre_x = x;
   return ret;
}

static_inline fix16_t Synth2_pitchToRate(fix16_t d) {
   return fix_mul(0xc /* 0.000185 */, fix_exp(fix_mul(0xec9 /* 0.057762 */, d)));
}

static_inline fix16_t Synth2_pulse_train(fix16_t m, fix16_t phase) {
   fix16_t pi_phase = fix_mul(0x3243f /* 3.141593 */, phase);
   fix16_t denominator1 = fix_sin(pi_phase);
   fix16_t tmp1 = 0x0 /* 0.000000 */;
   if (Synth2_near_zero(denominator1)) {
      tmp1 = 0x10000 /* 1.000000 */;
   }
   else {
      tmp1 = fix_sin(fix_mul(m, pi_phase));
      tmp1 = fix_div(tmp1, fix_mul(denominator1, m));
   }
   return tmp1;
}

fix16_t Synth2_osc(Synth2_osc_type& _ctx, fix16_t pitch, fix16_t pw, fix16_t wave);

fix16_t Synth2_svf_step(Synth2_svf_step_type& _ctx, fix16_t input, fix16_t g, fix16_t q, int32_t sel);

static_inline fix16_t Synth2_svf(Synth2_svf_type& _ctx, fix16_t input, fix16_t fc, fix16_t q, int32_t sel) {
   fc = fix_clip(fc, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   q = fix_clip(q, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   fix16_t fix_q = 0x20000 /* 2.000000 */ + fix_mul(0x20000 /* 2.000000 */, (- q));
   if (Synth2_change(_ctx.inst_177a7, fc)) {
      _ctx.g = fix_mul(0x8000 /* 0.500000 */, fc);
   }
   fix16_t x1 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   fix16_t x2 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   return fix_mul(0x8000 /* 0.500000 */, (x1 + x2));
}

fix16_t Synth2_lfo(Synth2_lfo_type& _ctx, fix16_t f, bool gate);

int32_t Synth2_mono_noteOn(Synth2_mono_noteOn_type& _ctx, int32_t n);

int32_t Synth2_mono_noteOff(Synth2_mono_noteOn_type& _ctx, int32_t n);

static_inline bool Synth2_mono_isGateOn(Synth2_mono_noteOn_type& _ctx) {
   return _ctx.count > 0;
}

static_inline fix16_t Synth2_process(Synth2_process_type& _ctx, fix16_t i) {
   bool gate = Synth2_mono_isGateOn(_ctx.monoin);
   fix16_t lfo1 = fix_mul(Synth2_lfo(_ctx.inst_15fb7, _ctx.lfo_rate, gate), _ctx.lfo_amt);
   fix16_t o1 = Synth2_osc(_ctx.inst_2e5b7, _ctx.pitch, lfo1 + _ctx.pw, _ctx.wave);
   fix16_t amp_env = 0.0f;
   fix16_t _if_temp_0 = 0.0f;
   if (gate) {
      _if_temp_0 = 0x10000 /* 1.000000 */;
   }
   else {
      _if_temp_0 = 0x0 /* 0.000000 */;
   }
   amp_env = Synth2_smooth(_ctx.inst_3dfb7, _if_temp_0);
   fix16_t output = fix_mul(amp_env, Synth2_svf(_ctx.inst_4a7b7, o1, _ctx.cut, _ctx.res, 0));
   return fix_mul(output, _ctx.volume);
}

static_inline void Synth2_noteOn(Synth2_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   _ctx.pitch = int_to_fix(Synth2_mono_noteOn(_ctx.monoin, note));
}

static_inline void Synth2_noteOff(Synth2_process_type& _ctx, int32_t note, int32_t channel) {
   _ctx.pitch = int_to_fix(Synth2_mono_noteOff(_ctx.monoin, note));
}

void Synth2_controlChange(Synth2_process_type& _ctx, int32_t control, int32_t value, int32_t channel);


#endif // SYNTH2_H
