/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef DELAY_H
#define DELAY_H

#include "vultin.h"
#include "delay.tables.h"

typedef struct Delay_smooth_type {
   fix16_t x;
} Delay_smooth_type;

typedef struct Delay_change_type {
   fix16_t pre_x;
} Delay_change_type;

typedef struct Delay_edge_type {
   bool pre_x;
} Delay_edge_type;

typedef struct Delay_each_type {
   int32_t count;
} Delay_each_type;

typedef struct Delay_phasor_type {
   Delay_change_type inst_18071;
   fix16_t phase;
   fix16_t rate;
} Delay_phasor_type;

typedef struct Delay_lfo_type {
   Delay_edge_type inst_11461;
   fix16_t phase;
} Delay_lfo_type;

typedef struct Delay_phd_osc_type {
   Delay_phasor_type inst_171c4;
   Delay_smooth_type inst_277c4;
   Delay_phasor_type inst_371c4;
   fix16_t pre_phase1;
} Delay_phd_osc_type;

typedef struct Delay_delay_type {
   std::array<fix16_t, 30000> buffer;
   int32_t write_pos;
} Delay_delay_type;

typedef struct Delay_mono_noteOn_type {
   int32_t count;
   std::array<int32_t, 4> notes;
   int32_t pre;
} Delay_mono_noteOn_type;

typedef struct Delay_mono_noteOn_type Delay_mono_noteOff_type;

typedef struct Delay_mono_noteOn_type Delay_mono_isGateOn_type;

typedef struct Delay_process_type {
   fix16_t detune;
   fix16_t feedback;
   Delay_lfo_type inst_16101;
   Delay_phd_osc_type inst_2c401;
   Delay_smooth_type inst_37701;
   Delay_smooth_type inst_47701;
   Delay_smooth_type inst_57701;
   Delay_delay_type inst_68e01;
   fix16_t lfo_amt;
   fix16_t lfo_rate;
   Delay_mono_noteOn_type notes;
   fix16_t pitch;
   fix16_t time;
   fix16_t volume;
} Delay_process_type;

typedef struct Delay_process_type Delay_noteOn_type;

typedef struct Delay_process_type Delay_noteOff_type;

typedef struct Delay_process_type Delay_controlChange_type;

typedef struct Delay_process_type Delay_default_type;

static_inline void Delay_smooth_type_init(Delay_smooth_type& _ctx) {
   _ctx.x = 0x0 /* 0.000000 */;
}

static_inline void Delay_change_type_init(Delay_change_type& _ctx) {
   _ctx.pre_x = 0x0 /* 0.000000 */;
}

static_inline void Delay_edge_type_init(Delay_edge_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Delay_each_type_init(Delay_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Delay_phasor_type_init(Delay_phasor_type& _ctx) {
   Delay_change_type_init(_ctx.inst_18071);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
}

static_inline void Delay_lfo_type_init(Delay_lfo_type& _ctx) {
   Delay_edge_type_init(_ctx.inst_11461);
   _ctx.phase = 0x0 /* 0.000000 */;
}

static_inline void Delay_phd_osc_type_init(Delay_phd_osc_type& _ctx) {
   Delay_phasor_type_init(_ctx.inst_171c4);
   Delay_smooth_type_init(_ctx.inst_277c4);
   Delay_phasor_type_init(_ctx.inst_371c4);
   _ctx.pre_phase1 = 0x0 /* 0.000000 */;
}

static_inline void Delay_delay_type_init(Delay_delay_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 30000) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0x0 /* 0.000000 */;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

void Delay_mono_noteOn_type_init(Delay_mono_noteOn_type& _ctx);

static_inline void Delay_mono_noteOff_type_init(Delay_mono_noteOff_type& _ctx) {
   Delay_mono_noteOn_type_init(_ctx);
}

static_inline void Delay_mono_isGateOn_type_init(Delay_mono_isGateOn_type& _ctx) {
   Delay_mono_noteOn_type_init(_ctx);
}

void Delay_process_type_init(Delay_process_type& _ctx);

static_inline void Delay_noteOn_type_init(Delay_noteOn_type& _ctx) {
   Delay_process_type_init(_ctx);
}

static_inline void Delay_noteOff_type_init(Delay_noteOff_type& _ctx) {
   Delay_process_type_init(_ctx);
}

static_inline void Delay_controlChange_type_init(Delay_controlChange_type& _ctx) {
   Delay_process_type_init(_ctx);
}

static_inline void Delay_default_type_init(Delay_default_type& _ctx) {
   Delay_process_type_init(_ctx);
}

static_inline fix16_t Delay_smooth(Delay_smooth_type& _ctx, fix16_t input) {
   _ctx.x = fix_mul(0x147 /* 0.005000 */, (input + (- _ctx.x))) + _ctx.x;
   return _ctx.x;
}

static_inline bool Delay_change(Delay_change_type& _ctx, fix16_t x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline bool Delay_edge(Delay_edge_type& _ctx, bool x) {
   bool v = (_ctx.pre_x != x) && (_ctx.pre_x == false);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Delay_each(Delay_each_type& _ctx, int32_t n) {
   bool ret = _ctx.count == 0;
   _ctx.count = (1 + _ctx.count) % n;
   return ret;
}

static_inline fix16_t Delay_pitchToRate(fix16_t d) {
   return fix_mul(0xc /* 0.000185 */, fix_exp(fix_mul(0xec9 /* 0.057762 */, d)));
}

fix16_t Delay_phasor(Delay_phasor_type& _ctx, fix16_t pitch, bool reset);

fix16_t Delay_lfo(Delay_lfo_type& _ctx, fix16_t f, bool gate);

static_inline fix16_t Delay_phd_osc(Delay_phd_osc_type& _ctx, fix16_t pitch, fix16_t detune) {
   fix16_t phase1 = Delay_phasor(_ctx.inst_171c4, pitch, false);
   fix16_t comp = 0x10000 /* 1.000000 */ + (- phase1);
   bool reset = (- phase1) + _ctx.pre_phase1 > 0x8000 /* 0.500000 */;
   _ctx.pre_phase1 = phase1;
   fix16_t phase2 = Delay_phasor(_ctx.inst_371c4, pitch + fix_mul(0x200000 /* 32.000000 */, Delay_smooth(_ctx.inst_277c4, detune)), reset);
   fix16_t sine = fix_sin(fix_mul(0x6487e /* 6.283185 */, phase2));
   return fix_mul(comp, sine);
}

fix16_t Delay_delay(Delay_delay_type& _ctx, fix16_t x, fix16_t time, fix16_t feedback);

int32_t Delay_mono_noteOn(Delay_mono_noteOn_type& _ctx, int32_t n);

int32_t Delay_mono_noteOff(Delay_mono_noteOn_type& _ctx, int32_t n);

static_inline bool Delay_mono_isGateOn(Delay_mono_noteOn_type& _ctx) {
   return _ctx.count > 0;
}

static_inline fix16_t Delay_process(Delay_process_type& _ctx, fix16_t input) {
   bool gate = Delay_mono_isGateOn(_ctx.notes);
   fix16_t lfo_val = fix_mul(Delay_lfo(_ctx.inst_16101, _ctx.lfo_rate, gate), _ctx.lfo_amt);
   fix16_t o1 = Delay_phd_osc(_ctx.inst_2c401, _ctx.pitch, lfo_val + _ctx.detune);
   fix16_t amp = 0.0f;
   fix16_t _if_temp_0 = 0.0f;
   if (gate) {
      _if_temp_0 = 0x10000 /* 1.000000 */;
   }
   else {
      _if_temp_0 = 0x0 /* 0.000000 */;
   }
   amp = Delay_smooth(_ctx.inst_37701, _if_temp_0);
   fix16_t osc_out = fix_mul(amp, o1);
   fix16_t delay_out = Delay_delay(_ctx.inst_68e01, osc_out, Delay_smooth(_ctx.inst_47701, _ctx.time), Delay_smooth(_ctx.inst_57701, _ctx.feedback));
   return fix_mul(0x8000 /* 0.500000 */, fix_mul((delay_out + osc_out), _ctx.volume));
}

static_inline void Delay_noteOn(Delay_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   _ctx.pitch = int_to_fix(Delay_mono_noteOn(_ctx.notes, note));
}

static_inline void Delay_noteOff(Delay_process_type& _ctx, int32_t note, int32_t channel) {
   _ctx.pitch = int_to_fix(Delay_mono_noteOff(_ctx.notes, note));
}

void Delay_controlChange(Delay_process_type& _ctx, int32_t control, fix16_t value, int32_t channel);

void Delay_default(Delay_process_type& _ctx);


#endif // DELAY_H
