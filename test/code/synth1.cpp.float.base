/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "synth1.h"

void Synth1_process_type_init(Synth1_process_type& _ctx) {
   _ctx.count = 0;
   _ctx.detune = 0.0f;
   _ctx.gate = 0;
   Synth1_lfo_type_init(_ctx.inst_17d3d);
   Synth1_phasor_type_init(_ctx.inst_2863d);
   Synth1_smooth_type_init(_ctx.inst_3dc3d);
   Synth1_phasor_type_init(_ctx.inst_4863d);
   Synth1_smooth_type_init(_ctx.inst_5dc3d);
   Synth1_smooth_type_init(_ctx.inst_6dc3d);
   _ctx.lfo_amt = 0.0f;
   _ctx.lfo_rate = 0.0f;
   _ctx.n1 = 0;
   _ctx.n2 = 0;
   _ctx.n3 = 0;
   _ctx.n4 = 0;
   _ctx.pitch = 0.0f;
   _ctx.pre_phase1 = 0.0f;
   _ctx.volume = 0.0f;
}

float Synth1_phasor(Synth1_phasor_type& _ctx, float pitch, bool reset) {
   if (Synth1_change(_ctx.inst_1be86, pitch)) {
      _ctx.rate = Synth1_pitchToRate(pitch);
   }
   if (reset) {
      _ctx.phase = 0.0f;
   }
   else {
      _ctx.phase = fmodf((_ctx.phase + _ctx.rate), 1.0f);
   }
   return _ctx.phase;
}

float Synth1_lfo(Synth1_lfo_type& _ctx, float f, int32_t gate) {
   float rate = 0.0002268f * f;
   if (Synth1_edge(_ctx.inst_11e7d, gate)) {
      _ctx.phase = 0.0f;
   }
   _ctx.phase = rate + _ctx.phase;
   if (_ctx.phase > 1.0f) {
      _ctx.phase = -1.0f + _ctx.phase;
   }
   return -0.5f + sinf(6.2831854f * _ctx.phase);
}

void Synth1_noteOn(Synth1_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
    switch (_ctx.count) {
      case 0:
         {
            _ctx.n1 = note;
            _ctx.pitch = int_to_float(note);
         }
         break;
      case 1:
         {
            _ctx.n2 = note;
            _ctx.pitch = int_to_float(note);
         }
         break;
      case 2:
         {
            _ctx.n3 = note;
            _ctx.pitch = int_to_float(note);
         }
         break;
      case 3:
         {
            _ctx.n4 = note;
            _ctx.pitch = int_to_float(note);
         }
         break;

   }
   if (_ctx.count <= 4) {
      _ctx.count = 1 + _ctx.count;
   }
   if (_ctx.count > 0) {
      _ctx.gate = 1;
   }
   else {
      _ctx.gate = 0;
   }
}

void Synth1_noteOff(Synth1_process_type& _ctx, int32_t note, int32_t channel) {
   bool found = false;
   if (note == _ctx.n1) {
      int32_t _t_temp_0 = _ctx.n2;
      int32_t _t_temp_1 = _ctx.n3;
      int32_t _t_temp_2 = _ctx.n4;
      _ctx.n1 = _t_temp_0;
      _ctx.n2 = _t_temp_1;
      _ctx.n3 = _t_temp_2;
      found = true;
   }
   else {
      if (note == _ctx.n2) {
         int32_t _t_temp_3 = _ctx.n3;
         int32_t _t_temp_4 = _ctx.n4;
         _ctx.n2 = _t_temp_3;
         _ctx.n3 = _t_temp_4;
         found = true;
      }
      else {
         if (note == _ctx.n3) {
            _ctx.n3 = _ctx.n4;
            found = true;
         }
         else {
            if (note == _ctx.n4) {
               found = true;
            }
         }
      }
   }
   if (found && _ctx.count > 0) {
      _ctx.count = -1 + _ctx.count;
   }
   if (_ctx.count > 0) {
      _ctx.gate = 1;
   }
   else {
      _ctx.gate = 0;
   }
   if (_ctx.count == 1) {
      _ctx.pitch = int_to_float(_ctx.n1);
   }
   if (_ctx.count == 2) {
      _ctx.pitch = int_to_float(_ctx.n2);
   }
   if (_ctx.count == 3) {
      _ctx.pitch = int_to_float(_ctx.n3);
   }
   if (_ctx.count == 4) {
      _ctx.pitch = int_to_float(_ctx.n4);
   }
}

void Synth1_controlChange(Synth1_process_type& _ctx, int32_t control, float value, int32_t channel) {
   if (control == 30) {
      _ctx.volume = 0.0078741f * value;
   }
   if (control == 31) {
      _ctx.detune = 0.0078741f * value;
   }
   if (control == 32) {
      _ctx.lfo_rate = 0.0078741f * value;
   }
   if (control == 33) {
      _ctx.lfo_amt = -1.0f + 0.0157481f * value;
   }
}

void Synth1_default(Synth1_process_type& _ctx) {
   _ctx.volume = 1.0f;
   _ctx.pitch = 45.0f;
   _ctx.detune = 0.8f;
   _ctx.lfo_rate = 0.0700001f;
   _ctx.lfo_amt = -0.8f;
}

