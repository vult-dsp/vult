/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef DELAY_H
#define DELAY_H

#include "vultin.h"
#include "delay.tables.h"

typedef struct Delay_smooth_type {
   float x;
} Delay_smooth_type;

typedef struct Delay_change_type {
   float pre_x;
} Delay_change_type;

typedef struct Delay_edge_type {
   bool pre_x;
} Delay_edge_type;

typedef struct Delay_each_type {
   int32_t count;
} Delay_each_type;

typedef struct Delay_phasor_type {
   Delay_change_type inst_18071;
   float phase;
   float rate;
} Delay_phasor_type;

typedef struct Delay_lfo_type {
   Delay_edge_type inst_11461;
   float phase;
} Delay_lfo_type;

typedef struct Delay_phd_osc_type {
   Delay_phasor_type inst_171c4;
   Delay_smooth_type inst_277c4;
   Delay_phasor_type inst_371c4;
   float pre_phase1;
} Delay_phd_osc_type;

typedef struct Delay_delay_type {
   float buffer[30000];
   int32_t write_pos;
} Delay_delay_type;

typedef struct Delay_mono_noteOn_type {
   int32_t count;
   int32_t notes[4];
   int32_t pre;
} Delay_mono_noteOn_type;

typedef struct Delay_process_type {
   float detune;
   float feedback;
   Delay_lfo_type inst_16101;
   Delay_phd_osc_type inst_2c401;
   Delay_smooth_type inst_37701;
   Delay_smooth_type inst_47701;
   Delay_smooth_type inst_57701;
   Delay_delay_type inst_68e01;
   float lfo_amt;
   float lfo_rate;
   Delay_mono_noteOn_type notes_5901;
   float pitch;
   float time;
   float volume;
} Delay_process_type;

static_inline void Delay_smooth_type_init(Delay_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Delay_change_type_init(Delay_change_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

static_inline void Delay_edge_type_init(Delay_edge_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Delay_each_type_init(Delay_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Delay_phasor_type_init(Delay_phasor_type& _ctx) {
   Delay_change_type_init(_ctx.inst_18071);
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
}

static_inline void Delay_lfo_type_init(Delay_lfo_type& _ctx) {
   Delay_edge_type_init(_ctx.inst_11461);
   _ctx.phase = 0.0f;
}

static_inline void Delay_phd_osc_type_init(Delay_phd_osc_type& _ctx) {
   Delay_phasor_type_init(_ctx.inst_171c4);
   Delay_smooth_type_init(_ctx.inst_277c4);
   Delay_phasor_type_init(_ctx.inst_371c4);
   _ctx.pre_phase1 = 0.0f;
}

static_inline void Delay_delay_type_init(Delay_delay_type& _ctx) {
   int32_t i_0 = 0;
   while ((i_0 < 30000)) {
      _ctx.buffer[i_0] = 0.0f;
      i_0 = (1 + i_0);
   }
   _ctx.write_pos = 0;
}

void Delay_mono_noteOn_type_init(Delay_mono_noteOn_type& _ctx);

void Delay_process_type_init(Delay_process_type& _ctx);

static_inline float Delay_smooth(Delay_smooth_type& _ctx, float input) {
   _ctx.x = ((0.005f * (input + (- _ctx.x))) + _ctx.x);
   return _ctx.x;
}

static_inline bool Delay_change(Delay_change_type& _ctx, float x) {
   bool v = (_ctx.pre_x != x);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Delay_edge(Delay_edge_type& _ctx, bool x) {
   bool v = ((_ctx.pre_x != x) && (_ctx.pre_x == false));
   _ctx.pre_x = x;
   return v;
}

static_inline bool Delay_each(Delay_each_type& _ctx, int32_t n) {
   bool ret = (_ctx.count == 0);
   _ctx.count = ((1 + _ctx.count) % n);
   return ret;
}

static_inline float Delay_pitchToRate(float d) {
   return (0.000185392290249f * exp((0.0577623f * d)));
}

float Delay_phasor(Delay_phasor_type& _ctx, float pitch, bool reset);

float Delay_lfo(Delay_lfo_type& _ctx, float f, bool gate);

static_inline float Delay_phd_osc(Delay_phd_osc_type& _ctx, float pitch, float detune) {
   float phase1 = Delay_phasor(_ctx.inst_171c4, pitch, false);
   float comp = (1.0f + (- phase1));
   bool reset = (((- phase1) + _ctx.pre_phase1) > 0.5f);
   _ctx.pre_phase1 = phase1;
   float phase2 = Delay_phasor(_ctx.inst_371c4, (pitch + (32.0f * Delay_smooth(_ctx.inst_277c4, detune))), reset);
   float sine = sin((6.28318530718f * phase2));
   return (comp * sine);
}

float Delay_delay(Delay_delay_type& _ctx, float x, float time, float feedback);

int32_t Delay_mono_noteOn(Delay_mono_noteOn_type& _ctx, int32_t n);

int32_t Delay_mono_noteOff(Delay_mono_noteOn_type& _ctx, int32_t n);

static_inline bool Delay_mono_isGateOn(Delay_mono_noteOn_type& _ctx) {
   return (_ctx.count > 0);
}

static_inline float Delay_process(Delay_process_type& _ctx, float input) {
   bool gate = Delay_mono_isGateOn(_ctx.notes_5901);
   float lfo_val = (Delay_lfo(_ctx.inst_16101, _ctx.lfo_rate, gate) * _ctx.lfo_amt);
   float o1 = Delay_phd_osc(_ctx.inst_2c401, _ctx.pitch, (lfo_val + _ctx.detune));
   float amp = 0.0f;
   float _if_temp_0 = 0.0f;
   if (gate) {
      _if_temp_0 = 1.0f;
   }
   else {
      _if_temp_0 = 0.0f;
   }
   amp = Delay_smooth(_ctx.inst_37701, _if_temp_0);
   float osc_out = (amp * o1);
   float delay_out = Delay_delay(_ctx.inst_68e01, osc_out, Delay_smooth(_ctx.inst_47701, _ctx.time), Delay_smooth(_ctx.inst_57701, _ctx.feedback));
   return (0.5f * ((delay_out + osc_out) * _ctx.volume));
}

static_inline void Delay_noteOn(Delay_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   _ctx.pitch = int_to_float(Delay_mono_noteOn(_ctx.notes_5901, note));
}

static_inline void Delay_noteOff(Delay_process_type& _ctx, int32_t note, int32_t channel) {
   _ctx.pitch = int_to_float(Delay_mono_noteOff(_ctx.notes_5901, note));
}

void Delay_controlChange(Delay_process_type& _ctx, int32_t control, float value, int32_t channel);

void Delay_default(Delay_process_type& _ctx);


#endif // DELAY_H
