/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "synth2.h"

void Synth2_osc_type_init(Synth2_osc_type& _ctx) {
   Synth2_change_type_init(_ctx.inst_177e5);
   Synth2_dcblock_type_init(_ctx.inst_24fe5);
   _ctx.m = 0.0f;
   _ctx.output = 0.0f;
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
   _ctx.state_pulse = 0.0f;
   _ctx.state_saw = 0.0f;
   _ctx.state_triang = 0.0f;
}

void Synth2_mono_noteOn_type_init(Synth2_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while (i_0 < 4) {
      _ctx.notes[static_cast<uint32_t>(i_0)] = 0;
      i_0 = 1 + i_0;
   }
   _ctx.pre = 0;
}

void Synth2_default(Synth2_process_type& _ctx) {
   _ctx.volume = 1.0f;
   _ctx.pw = 0.0f;
   _ctx.pitch = 42.0f;
   _ctx.cut = 1.0f;
   _ctx.res = 0.0f;
   _ctx.amp_s = 1.0f;
   _ctx.lfo_amt = 0.5f;
   _ctx.lfo_rate = 0.0f;
}

void Synth2_process_type_init(Synth2_process_type& _ctx) {
   _ctx.amp_s = 0.0f;
   _ctx.cut = 0.0f;
   Synth2_lfo_type_init(_ctx.inst_15fb7);
   Synth2_osc_type_init(_ctx.inst_2e5b7);
   Synth2_smooth_type_init(_ctx.inst_3dfb7);
   Synth2_svf_type_init(_ctx.inst_4a7b7);
   _ctx.lfo_amt = 0.0f;
   _ctx.lfo_rate = 0.0f;
   Synth2_mono_noteOn_type_init(_ctx.monoin);
   _ctx.pitch = 0.0f;
   _ctx.pw = 0.0f;
   _ctx.res = 0.0f;
   _ctx.volume = 0.0f;
   _ctx.wave = 0.0f;
   Synth2_default(_ctx);
}

float Synth2_osc(Synth2_osc_type& _ctx, float pitch, float pw, float wave) {
   float fixed_pitch = 0.0f;
   if (wave < 0.666666f) {
      fixed_pitch = pitch;
   }
   else {
      fixed_pitch = 12.0f + pitch;
   }
   if (Synth2_change(_ctx.inst_177e5, fixed_pitch)) {
      _ctx.rate = Synth2_pitchToRate(fixed_pitch);
      float p = 1.0f / _ctx.rate;
      float maxHarmonics = floorf(0.5f * p);
      _ctx.m = 1.0f + 2.0f * maxHarmonics;
   }
   float shift05 = 0.5f + 0.49f * pw;
   float shift = shift05 + _ctx.phase;
   if (shift > 1.0f) {
      shift = -1.0f + shift;
   }
   float tmp1 = Synth2_pulse_train(_ctx.m, _ctx.phase);
   float tmp2 = Synth2_pulse_train(_ctx.m, shift);
   _ctx.phase = _ctx.phase + _ctx.rate;
   if (_ctx.phase > 1.0f) {
      _ctx.phase = -1.0f + _ctx.phase;
   }
   _ctx.state_pulse = float_clip(tmp1 + (- tmp2) + 0.9995f * _ctx.state_pulse, -1.0f, 1.0f);
   _ctx.state_saw = float_clip(0.5f * (tmp1 + tmp2 + -2.0f * _ctx.rate) / shift05 + 0.9995f * _ctx.state_saw, -1.0f, 1.0f);
   _ctx.state_triang = float_clip(0.9995f * _ctx.state_triang + 2.0f * _ctx.state_pulse * _ctx.rate, -1.0f, 1.0f);
   if (wave < 0.333333f) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      if (wave < 0.666666f) {
         _ctx.output = 2.0f * _ctx.state_saw;
      }
      else {
         _ctx.output = 2.0f * (1.0f + pw) * _ctx.state_triang;
      }
   }
   _ctx.output = Synth2_dcblock(_ctx.inst_24fe5, _ctx.output);
   return float_clip(0.25f * _ctx.output, -1.0f, 1.0f);
}

float Synth2_svf_step(Synth2_svf_step_type& _ctx, float input, float g, float q, int32_t sel) {
   float low = g * _ctx.dband + _ctx.dlow;
   float high = input + (- low) + (- q * _ctx.dband);
   float band = g * high + _ctx.dband;
   float notch = high + low;
   _ctx.dband = float_clip(band, -1.0f, 1.0f);
   _ctx.dlow = float_clip(low, -1.0f, 1.0f);
   float output = 0.0f;
    switch (sel) {
      case 0:
         output = low;
         break;
      case 1:
         output = high;
         break;
      case 2:
         output = band;
         break;
   default:
      output = notch;
      break;
   }
   return output;
}

float Synth2_lfo(Synth2_lfo_type& _ctx, float f, bool gate) {
   float rate = 100.0f * f * Synth2_minFixed() + Synth2_minFixed();
   if (Synth2_edge(_ctx.inst_1445f, gate)) {
      _ctx.phase = 0.0f;
   }
   if (Synth2_each(_ctx.inst_2cb5f, 4)) {
      _ctx.phase = rate + _ctx.phase;
   }
   if (_ctx.phase > 1.0f) {
      _ctx.phase = -1.0f + _ctx.phase;
   }
   return 0.5f + sinf(6.283185f * _ctx.phase);
}

int32_t Synth2_mono_noteOn(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   if (_ctx.count < 4) {
      _ctx.notes[static_cast<uint32_t>(_ctx.count)] = n;
      _ctx.pre = n;
      if (_ctx.count < 4) {
         _ctx.count = 1 + _ctx.count;
      }
   }
   return _ctx.pre;
}

int32_t Synth2_mono_noteOff(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while (i < 4 && (found == false)) {
      if (_ctx.notes[static_cast<uint32_t>(i)] == n) {
         pos = i;
         found = true;
      }
      i = 1 + i;
   }
   if (found) {
      int32_t k = 1 + pos;
      while (k < 4) {
         _ctx.notes[static_cast<uint32_t>(-1 + k)] = _ctx.notes[static_cast<uint32_t>(k)];
         k = 1 + k;
      }
      if (found && _ctx.count > 0) {
         _ctx.count = -1 + _ctx.count;
         _ctx.pre = _ctx.notes[static_cast<uint32_t>(-1 + _ctx.count)];
      }
   }
   return _ctx.pre;
}

void Synth2_controlChange(Synth2_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   float value_0_1 = 0.007874f * int_to_float(value);
   float value_m1_1 = -1.0f + 2.0f * value_0_1;
   if (control == 30) {
      _ctx.volume = value_0_1;
   }
   if (control == 31) {
      _ctx.wave = value_0_1;
   }
   if (control == 32) {
      _ctx.pw = value_0_1;
   }
   if (control == 33) {
      _ctx.lfo_rate = value_0_1;
   }
   if (control == 34) {
      _ctx.lfo_amt = value_m1_1;
   }
   if (control == 35) {
      _ctx.cut = value_0_1;
   }
   if (control == 36) {
      _ctx.res = value_0_1;
   }
}

