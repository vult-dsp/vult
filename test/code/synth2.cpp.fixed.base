/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "synth2.h"

void Synth2_osc_type_init(Synth2_osc_type& _ctx) {
   Synth2_change_type_init(_ctx.inst_177e5);
   Synth2_dcblock_type_init(_ctx.inst_24fe5);
   _ctx.m = 0x0 /* 0.000000 */;
   _ctx.output = 0x0 /* 0.000000 */;
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.state_pulse = 0x0 /* 0.000000 */;
   _ctx.state_saw = 0x0 /* 0.000000 */;
   _ctx.state_triang = 0x0 /* 0.000000 */;
}

void Synth2_mono_noteOn_type_init(Synth2_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while (i_0 < 4) {
      _ctx.notes[static_cast<uint32_t>(i_0)] = 0;
      i_0 = 1 + i_0;
   }
   _ctx.pre = 0;
}

void Synth2_default(Synth2_process_type& _ctx) {
   _ctx.volume = 0x10000 /* 1.000000 */;
   _ctx.pw = 0x0 /* 0.000000 */;
   _ctx.pitch = 0x2a0000 /* 42.000000 */;
   _ctx.cut = 0x10000 /* 1.000000 */;
   _ctx.res = 0x0 /* 0.000000 */;
   _ctx.amp_s = 0x10000 /* 1.000000 */;
   _ctx.lfo_amt = 0x8000 /* 0.500000 */;
   _ctx.lfo_rate = 0x0 /* 0.000000 */;
}

void Synth2_process_type_init(Synth2_process_type& _ctx) {
   _ctx.amp_s = 0x0 /* 0.000000 */;
   _ctx.cut = 0x0 /* 0.000000 */;
   Synth2_lfo_type_init(_ctx.inst_15fb7);
   Synth2_osc_type_init(_ctx.inst_2e5b7);
   Synth2_smooth_type_init(_ctx.inst_3dfb7);
   Synth2_svf_type_init(_ctx.inst_4a7b7);
   _ctx.lfo_amt = 0x0 /* 0.000000 */;
   _ctx.lfo_rate = 0x0 /* 0.000000 */;
   Synth2_mono_noteOn_type_init(_ctx.monoin);
   _ctx.pitch = 0x0 /* 0.000000 */;
   _ctx.pw = 0x0 /* 0.000000 */;
   _ctx.res = 0x0 /* 0.000000 */;
   _ctx.volume = 0x0 /* 0.000000 */;
   _ctx.wave = 0x0 /* 0.000000 */;
   Synth2_default(_ctx);
}

fix16_t Synth2_pulse_train(fix16_t m, fix16_t phase) {
   fix16_t pi_phase = fix_mul(0x3243f /* 3.141593 */, phase);
   fix16_t denominator1 = fix_sin(pi_phase);
   fix16_t tmp1 = 0x0 /* 0.000000 */;
   if (Synth2_near_zero(denominator1)) {
      tmp1 = 0x10000 /* 1.000000 */;
   }
   else {
      tmp1 = fix_sin(fix_mul(m, pi_phase));
      tmp1 = fix_div(tmp1, fix_mul(denominator1, m));
   }
   return tmp1;
}

fix16_t Synth2_osc(Synth2_osc_type& _ctx, fix16_t pitch, fix16_t pw, fix16_t wave) {
   fix16_t fixed_pitch = 0x0 /* 0.000000 */;
   if (wave < 0xaaaa /* 0.666667 */) {
      fixed_pitch = pitch;
   }
   else {
      fixed_pitch = 0xc0000 /* 12.000000 */ + pitch;
   }
   if (Synth2_change(_ctx.inst_177e5, fixed_pitch)) {
      _ctx.rate = Synth2_pitchToRate(fixed_pitch);
      fix16_t p = fix_div(0x10000 /* 1.000000 */, _ctx.rate);
      fix16_t maxHarmonics = fix_floor(fix_mul(0x8000 /* 0.500000 */, p));
      _ctx.m = 0x10000 /* 1.000000 */ + fix_mul(0x20000 /* 2.000000 */, maxHarmonics);
   }
   fix16_t shift05 = 0x8000 /* 0.500000 */ + fix_mul(0x7d70 /* 0.490000 */, pw);
   fix16_t shift = shift05 + _ctx.phase;
   if (shift > 0x10000 /* 1.000000 */) {
      shift = -0x10000 /* -1.000000 */ + shift;
   }
   fix16_t tmp1 = Synth2_pulse_train(_ctx.m, _ctx.phase);
   fix16_t tmp2 = Synth2_pulse_train(_ctx.m, shift);
   _ctx.phase = _ctx.phase + _ctx.rate;
   if (_ctx.phase > 0x10000 /* 1.000000 */) {
      _ctx.phase = -0x10000 /* -1.000000 */ + _ctx.phase;
   }
   _ctx.state_pulse = fix_clip(tmp1 + (- tmp2) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_pulse), -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   _ctx.state_saw = fix_clip(fix_mul(0x8000 /* 0.500000 */, fix_div(tmp1 + tmp2 + fix_mul(-0x20000 /* -2.000000 */, _ctx.rate), shift05)) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_saw), -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   _ctx.state_triang = fix_clip(fix_mul(0xffdf /* 0.999500 */, _ctx.state_triang) + fix_mul(0x20000 /* 2.000000 */, fix_mul(_ctx.state_pulse, _ctx.rate)), -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   if (wave < 0x5555 /* 0.333333 */) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      if (wave < 0xaaaa /* 0.666667 */) {
         _ctx.output = fix_mul(0x20000 /* 2.000000 */, _ctx.state_saw);
      }
      else {
         _ctx.output = fix_mul(0x20000 /* 2.000000 */, fix_mul(0x10000 /* 1.000000 */ + pw, _ctx.state_triang));
      }
   }
   _ctx.output = Synth2_dcblock(_ctx.inst_24fe5, _ctx.output);
   return fix_clip(fix_mul(0x4000 /* 0.250000 */, _ctx.output), -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
}

fix16_t Synth2_svf_step(Synth2_svf_step_type& _ctx, fix16_t input, fix16_t g, fix16_t q, int32_t sel) {
   fix16_t low = fix_mul(g, _ctx.dband) + _ctx.dlow;
   fix16_t high = input + (- low) + (- fix_mul(q, _ctx.dband));
   fix16_t band = fix_mul(g, high) + _ctx.dband;
   fix16_t notch = high + low;
   _ctx.dband = fix_clip(band, -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   _ctx.dlow = fix_clip(low, -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   fix16_t output = 0x0 /* 0.000000 */;
    switch (sel) {
      case 0:
         output = low;
         break;
      case 1:
         output = high;
         break;
      case 2:
         output = band;
         break;

      default:
         output = notch;
         break;
   }
   return output;
}

fix16_t Synth2_svf(Synth2_svf_type& _ctx, fix16_t input, fix16_t fc, fix16_t q, int32_t sel) {
   fc = fix_clip(fc, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   q = fix_clip(q, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   fix16_t fix_q = 0x20000 /* 2.000000 */ + fix_mul(0x20000 /* 2.000000 */, (- q));
   if (Synth2_change(_ctx.inst_177a7, fc)) {
      _ctx.g = fix_mul(0x8000 /* 0.500000 */, fc);
   }
   fix16_t x1 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   fix16_t x2 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   return fix_mul(0x8000 /* 0.500000 */, x1 + x2);
}

fix16_t Synth2_lfo(Synth2_lfo_type& _ctx, fix16_t f, bool gate) {
   fix16_t rate = fix_mul(0x640000 /* 100.000000 */, fix_mul(f, Synth2_minFixed())) + Synth2_minFixed();
   if (Synth2_edge(_ctx.inst_1445f, gate)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   if (Synth2_each(_ctx.inst_2cb5f, 4)) {
      _ctx.phase = rate + _ctx.phase;
   }
   if (_ctx.phase > 0x10000 /* 1.000000 */) {
      _ctx.phase = -0x10000 /* -1.000000 */ + _ctx.phase;
   }
   return 0x8000 /* 0.500000 */ + fix_sin(fix_mul(0x6487e /* 6.283185 */, _ctx.phase));
}

int32_t Synth2_mono_noteOn(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   if (_ctx.count < 4) {
      _ctx.notes[static_cast<uint32_t>(_ctx.count)] = n;
      _ctx.pre = n;
      if (_ctx.count < 4) {
         _ctx.count = 1 + _ctx.count;
      }
   }
   return _ctx.pre;
}

int32_t Synth2_mono_noteOff(Synth2_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while (i < 4 && (found == false)) {
      if (_ctx.notes[static_cast<uint32_t>(i)] == n) {
         pos = i;
         found = true;
      }
      i = 1 + i;
   }
   if (found) {
      int32_t k = 1 + pos;
      while (k < 4) {
         _ctx.notes[static_cast<uint32_t>(-1 + k)] = _ctx.notes[static_cast<uint32_t>(k)];
         k = 1 + k;
      }
      if (found && _ctx.count > 0) {
         _ctx.count = -1 + _ctx.count;
         _ctx.pre = _ctx.notes[static_cast<uint32_t>(-1 + _ctx.count)];
      }
   }
   return _ctx.pre;
}

fix16_t Synth2_process(Synth2_process_type& _ctx, fix16_t i) {
   bool gate = Synth2_mono_isGateOn(_ctx.monoin);
   fix16_t lfo1 = fix_mul(Synth2_lfo(_ctx.inst_15fb7, _ctx.lfo_rate, gate), _ctx.lfo_amt);
   fix16_t o1 = Synth2_osc(_ctx.inst_2e5b7, _ctx.pitch, lfo1 + _ctx.pw, _ctx.wave);
   fix16_t amp_env = 0x0 /* 0.000000 */;
   fix16_t _if_temp_0 = 0x0 /* 0.000000 */;
   if (gate) {
      _if_temp_0 = 0x10000 /* 1.000000 */;
   }
   else {
      _if_temp_0 = 0x0 /* 0.000000 */;
   }
   amp_env = Synth2_smooth(_ctx.inst_3dfb7, _if_temp_0);
   fix16_t output = fix_mul(amp_env, Synth2_svf(_ctx.inst_4a7b7, o1, _ctx.cut, _ctx.res, 0));
   return fix_mul(output, _ctx.volume);
}

void Synth2_controlChange(Synth2_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   fix16_t value_0_1 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   fix16_t value_m1_1 = -0x10000 /* -1.000000 */ + fix_mul(0x20000 /* 2.000000 */, value_0_1);
   if (control == 30) {
      _ctx.volume = value_0_1;
   }
   if (control == 31) {
      _ctx.wave = value_0_1;
   }
   if (control == 32) {
      _ctx.pw = value_0_1;
   }
   if (control == 33) {
      _ctx.lfo_rate = value_0_1;
   }
   if (control == 34) {
      _ctx.lfo_amt = value_m1_1;
   }
   if (control == 35) {
      _ctx.cut = value_0_1;
   }
   if (control == 36) {
      _ctx.res = value_0_1;
   }
}

