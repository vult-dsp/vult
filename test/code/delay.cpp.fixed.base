/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "delay.h"

void Delay_mono_noteOn_type_init(Delay_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while (i_0 < 4) {
      _ctx.notes[static_cast<uint32_t>(i_0)] = 0;
      i_0 = (1 + i_0);
   }
   _ctx.pre = 0;
}

void Delay_process_type_init(Delay_process_type& _ctx) {
   _ctx.detune = 0x0 /* 0.000000 */;
   _ctx.feedback = 0x0 /* 0.000000 */;
   Delay_lfo_type_init(_ctx.inst_16101);
   Delay_phd_osc_type_init(_ctx.inst_2c401);
   Delay_smooth_type_init(_ctx.inst_37701);
   Delay_smooth_type_init(_ctx.inst_47701);
   Delay_smooth_type_init(_ctx.inst_57701);
   Delay_delay_type_init(_ctx.inst_68e01);
   _ctx.lfo_amt = 0x0 /* 0.000000 */;
   _ctx.lfo_rate = 0x0 /* 0.000000 */;
   Delay_mono_noteOn_type_init(_ctx.notes);
   _ctx.pitch = 0x0 /* 0.000000 */;
   _ctx.time = 0x0 /* 0.000000 */;
   _ctx.volume = 0x0 /* 0.000000 */;
}

fix16_t Delay_phasor(Delay_phasor_type& _ctx, fix16_t pitch, bool reset) {
   if (Delay_change(_ctx.inst_18071, pitch)) {
      _ctx.rate = Delay_pitchToRate(pitch);
   }
   if (reset) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else {
      _ctx.phase = ((_ctx.phase + _ctx.rate) % 0x10000 /* 1.000000 */);
   }
   return _ctx.phase;
}

fix16_t Delay_lfo(Delay_lfo_type& _ctx, fix16_t f, bool gate) {
   fix16_t rate = fix_mul(0xe /* 0.000227 */, f);
   if (Delay_edge(_ctx.inst_11461, gate)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   _ctx.phase = (rate + _ctx.phase);
   if (_ctx.phase > 0x10000 /* 1.000000 */) {
      _ctx.phase = (-0x10000 /* -1.000000 */ + _ctx.phase);
   }
   return (-0x8000 /* -0.500000 */ + fix_sin(fix_mul(0x6487e /* 6.283185 */, _ctx.phase)));
}

fix16_t Delay_delay(Delay_delay_type& _ctx, fix16_t x, fix16_t time, fix16_t feedback) {
   time = fix_clip(time, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   feedback = fix_clip(feedback, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   fix16_t index_r = fix_mul(time, int_to_fix(30000));
   int32_t index_i = int(fix_floor(index_r));
   int32_t delta = ((- index_i) + _ctx.write_pos);
   int32_t read_pos = 0;
   if (delta < 0) {
      read_pos = (30000 + delta);
   }
   else {
      read_pos = delta;
   }
   fix16_t decimal = (index_r + (- int_to_fix(index_i)));
   fix16_t x1 = _ctx.buffer[static_cast<uint32_t>(read_pos)];
   fix16_t x2 = _ctx.buffer[static_cast<uint32_t>(((1 + read_pos) % 30000))];
   fix16_t ret = (x1 + fix_mul(decimal, (x2 + (- x1))));
   _ctx.write_pos = ((1 + _ctx.write_pos) % 30000);
   _ctx.buffer[static_cast<uint32_t>(_ctx.write_pos)] = fix_clip((x + fix_mul(feedback, ret)), -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   return ret;
}

int32_t Delay_mono_noteOn(Delay_mono_noteOn_type& _ctx, int32_t n) {
   if (_ctx.count < 4) {
      _ctx.notes[static_cast<uint32_t>(_ctx.count)] = n;
      _ctx.pre = n;
      if (_ctx.count < 4) {
         _ctx.count = (1 + _ctx.count);
      }
   }
   return _ctx.pre;
}

int32_t Delay_mono_noteOff(Delay_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while ((i < 4) && (found == false)) {
      if (_ctx.notes[static_cast<uint32_t>(i)] == n) {
         pos = i;
         found = true;
      }
      i = (1 + i);
   }
   if (found) {
      int32_t k = (1 + pos);
      while (k < 4) {
         _ctx.notes[static_cast<uint32_t>((-1 + k))] = _ctx.notes[static_cast<uint32_t>(k)];
         k = (1 + k);
      }
      if (found && (_ctx.count > 0)) {
         _ctx.count = (-1 + _ctx.count);
         _ctx.pre = _ctx.notes[static_cast<uint32_t>((-1 + _ctx.count))];
      }
   }
   return _ctx.pre;
}

void Delay_controlChange(Delay_process_type& _ctx, int32_t control, fix16_t value, int32_t channel) {
   if (control == 30) {
      _ctx.volume = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 31) {
      _ctx.detune = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 32) {
      _ctx.lfo_rate = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 33) {
      _ctx.lfo_amt = fix_mul(0x20000 /* 2.000000 */, (-0x8000 /* -0.500000 */ + fix_mul(0x204 /* 0.007874 */, value)));
   }
   if (control == 34) {
      _ctx.time = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 35) {
      _ctx.feedback = fix_mul(0x204 /* 0.007874 */, value);
   }
}

void Delay_default(Delay_process_type& _ctx) {
   _ctx.volume = 0x10000 /* 1.000000 */;
   _ctx.pitch = 0x2d0000 /* 45.000000 */;
   _ctx.detune = 0xcccc /* 0.800000 */;
   _ctx.lfo_rate = 0x11eb /* 0.070000 */;
   _ctx.lfo_amt = -0xcccc /* -0.800000 */;
   _ctx.time = 0x8000 /* 0.500000 */;
   _ctx.feedback = 0x8000 /* 0.500000 */;
}

