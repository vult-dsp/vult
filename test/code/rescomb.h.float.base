/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */
#ifndef RESCOMB_H
#define RESCOMB_H

#include "vultin.h"
#include "rescomb.tables.h"

typedef struct Util_edge_type {
   bool pre;
} Util_edge_type;

typedef struct Util_change_type {
   float pre_x;
} Util_change_type;

typedef struct Util_dcblock_type {
   float x1;
   float y1;
} Util_dcblock_type;

typedef struct Util_smooth_type {
   float x;
} Util_smooth_type;

typedef struct Util_average2_type {
   float x0;
} Util_average2_type;

typedef struct Rescomb_delay_type {
   std::array<float, 675> buffer;
   int32_t write_pos;
} Rescomb_delay_type;

typedef struct Rescomb_do_type {
   Util_change_type inst_1b000;
   Util_dcblock_type inst_26400;
   Rescomb_delay_type inst_3a900;
   float output;
   float stone;
} Rescomb_do_type;

typedef struct Rescomb_process_type {
   Rescomb_do_type inst_100b6;
} Rescomb_process_type;

typedef struct Rescomb_process_type Rescomb_noteOn_type;

typedef struct Rescomb_process_type Rescomb_noteOff_type;

typedef struct Rescomb_process_type Rescomb_controlChange_type;

typedef struct Rescomb_process_type Rescomb_default_type;

static_inline void Util_edge_type_init(Util_edge_type& _ctx) {
   _ctx.pre = false;
}

static_inline void Util_change_type_init(Util_change_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

static_inline void Util_dcblock_type_init(Util_dcblock_type& _ctx) {
   _ctx.x1 = 0.0f;
   _ctx.y1 = 0.0f;
}

static_inline void Util_smooth_type_init(Util_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Util_average2_type_init(Util_average2_type& _ctx) {
   _ctx.x0 = 0.0f;
}

static_inline void Rescomb_delay_type_init(Rescomb_delay_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 675) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0.0f;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

void Rescomb_do_type_init(Rescomb_do_type& _ctx);

static_inline void Rescomb_process_type_init(Rescomb_process_type& _ctx) {
   Rescomb_do_type_init(_ctx.inst_100b6);
}

static_inline void Rescomb_noteOn_type_init(Rescomb_noteOn_type& _ctx) {
   Rescomb_process_type_init(_ctx);
}

static_inline void Rescomb_noteOff_type_init(Rescomb_noteOff_type& _ctx) {
   Rescomb_process_type_init(_ctx);
}

static_inline void Rescomb_controlChange_type_init(Rescomb_controlChange_type& _ctx) {
   Rescomb_process_type_init(_ctx);
}

static_inline void Rescomb_default_type_init(Rescomb_default_type& _ctx) {
   Rescomb_process_type_init(_ctx);
}

static_inline float Saturate_soft_tanh_table_raw_c0(int32_t index) {
   return Saturate_soft_tanh_table_c0[static_cast<uint32_t>(index)];
}

static_inline float Saturate_soft_tanh_table_raw_c1(int32_t index) {
   return Saturate_soft_tanh_table_c1[static_cast<uint32_t>(index)];
}

static_inline float Saturate_soft_tanh_table_raw_c2(int32_t index) {
   return Saturate_soft_tanh_table_c2[static_cast<uint32_t>(index)];
}

static_inline float Saturate_soft_tanh_table(float x) {
   int32_t index = int_clip(float_to_int((x - -24.0f) * 5.0f), 0, 240);
   return Saturate_soft_tanh_table_c0[static_cast<uint32_t>(index)] + x * (Saturate_soft_tanh_table_c1[static_cast<uint32_t>(index)] + Saturate_soft_tanh_table_c2[static_cast<uint32_t>(index)] * x);
}

static_inline float Saturate_soft_process(float x) {
   return Saturate_soft_tanh_table(x);
}

static_inline void Saturate_soft_noteOn(int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Saturate_soft_noteOff(int32_t note, int32_t channel) {
}

static_inline void Saturate_soft_controlChange(int32_t control, int32_t value, int32_t channel) {
}

static_inline void Saturate_soft_default() {
}

static_inline bool Util_edge(Util_edge_type& _ctx, bool x) {
   bool ret = x && (_ctx.pre == false);
   _ctx.pre = x;
   return ret;
}

static_inline bool Util_change(Util_change_type& _ctx, float x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline float Util_map(float x, float x0, float x1, float y0, float y1) {
   return y0 + ((x + (- x0)) * (y1 + (- y0))) / (x1 + (- x0));
}

static_inline float Util_dcblock(Util_dcblock_type& _ctx, float x0) {
   float y0 = x0 + (- _ctx.x1) + 0.995f * _ctx.y1;
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

static_inline float Util_smooth(Util_smooth_type& _ctx, float input) {
   _ctx.x = 0.005f * (input + (- _ctx.x)) + _ctx.x;
   return _ctx.x;
}

static_inline float Util_average2(Util_average2_type& _ctx, float x1) {
   float result = 0.5f * (x1 + _ctx.x0);
   _ctx.x0 = x1;
   return result;
}

static_inline float Util_cubic_clipper(float x) {
   if (x <= -0.666667f) {
      return -0.666667f;
   }
   else {
      if (x >= 0.666666f) {
         return 0.666666f;
      }
      else {
         return x + -0.333334f * x * x * x;
      }
   }
}

static_inline float Util_pitchToRate_1024_raw_c0(int32_t index) {
   return Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024_raw_c1(int32_t index) {
   return Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024_raw_c2(int32_t index) {
   return Util_pitchToRate_1024_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024(float pitch) {
   int32_t index = int_clip(float_to_int(pitch * 0.244094f), 0, 31);
   return Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)] + pitch * (Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)] + Util_pitchToRate_1024_c2[static_cast<uint32_t>(index)] * pitch);
}

static_inline float Util_pitchToRate_raw_c0(int32_t index) {
   return Util_pitchToRate_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_raw_c1(int32_t index) {
   return Util_pitchToRate_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_raw_c2(int32_t index) {
   return Util_pitchToRate_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate(float pitch) {
   int32_t index = int_clip(float_to_int(pitch * 0.244094f), 0, 31);
   return Util_pitchToRate_c0[static_cast<uint32_t>(index)] + pitch * (Util_pitchToRate_c1[static_cast<uint32_t>(index)] + Util_pitchToRate_c2[static_cast<uint32_t>(index)] * pitch);
}

static_inline float Util_cvToPitch(float cv) {
   return 24.0f + 120.0f * cv;
}

static_inline float Util_cvToRate_1024_raw_c0(int32_t index) {
   return Util_cvToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024_raw_c1(int32_t index) {
   return Util_cvToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024_raw_c2(int32_t index) {
   return Util_cvToRate_1024_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024(float cv) {
   int32_t index = int_clip(float_to_int(cv * 34.444444f), 0, 31);
   return Util_cvToRate_1024_c0[static_cast<uint32_t>(index)] + cv * (Util_cvToRate_1024_c1[static_cast<uint32_t>(index)] + Util_cvToRate_1024_c2[static_cast<uint32_t>(index)] * cv);
}

static_inline float Util_cvToRate_raw_c0(int32_t index) {
   return Util_cvToRate_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_raw_c1(int32_t index) {
   return Util_cvToRate_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_raw_c2(int32_t index) {
   return Util_cvToRate_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate(float cv) {
   int32_t index = int_clip(float_to_int(cv * 141.111111f), 0, 127);
   return Util_cvToRate_c0[static_cast<uint32_t>(index)] + cv * (Util_cvToRate_c1[static_cast<uint32_t>(index)] + Util_cvToRate_c2[static_cast<uint32_t>(index)] * cv);
}

static_inline float Util_pitchToCv(float pitch) {
   return -0.2f + 0.008333f * pitch;
}

static_inline float Util_cvToperiod_raw_c0(int32_t index) {
   return Util_cvToperiod_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod_raw_c1(int32_t index) {
   return Util_cvToperiod_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod_raw_c2(int32_t index) {
   return Util_cvToperiod_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod(float cv) {
   int32_t index = int_clip(float_to_int(cv * 31.0f), 0, 31);
   return Util_cvToperiod_c0[static_cast<uint32_t>(index)] + cv * (Util_cvToperiod_c1[static_cast<uint32_t>(index)] + Util_cvToperiod_c2[static_cast<uint32_t>(index)] * cv);
}

static_inline float Util_cvTokHz_raw_c0(int32_t index) {
   return Util_cvTokHz_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz_raw_c1(int32_t index) {
   return Util_cvTokHz_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz_raw_c2(int32_t index) {
   return Util_cvTokHz_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz(float cv) {
   int32_t index = int_clip(float_to_int(cv * 31.0f), 0, 31);
   return Util_cvTokHz_c0[static_cast<uint32_t>(index)] + cv * (Util_cvTokHz_c1[static_cast<uint32_t>(index)] + Util_cvTokHz_c2[static_cast<uint32_t>(index)] * cv);
}

float Rescomb_delay(Rescomb_delay_type& _ctx, float x, float cv);

static_inline float Rescomb_toneCurve_raw_c0(int32_t index) {
   return Rescomb_toneCurve_c0[static_cast<uint32_t>(index)];
}

static_inline float Rescomb_toneCurve_raw_c1(int32_t index) {
   return Rescomb_toneCurve_c1[static_cast<uint32_t>(index)];
}

static_inline float Rescomb_toneCurve_raw_c2(int32_t index) {
   return Rescomb_toneCurve_c2[static_cast<uint32_t>(index)];
}

static_inline float Rescomb_toneCurve(float tone) {
   int32_t index = int_clip(float_to_int((tone - -1.2f) * 26.25f), 0, 63);
   return Rescomb_toneCurve_c0[static_cast<uint32_t>(index)] + tone * (Rescomb_toneCurve_c1[static_cast<uint32_t>(index)] + Rescomb_toneCurve_c2[static_cast<uint32_t>(index)] * tone);
}

static_inline float Rescomb_do(Rescomb_do_type& _ctx, float in, float cv, float tone, float res) {
   if (Util_change(_ctx.inst_1b000, tone)) {
      _ctx.stone = Rescomb_toneCurve(tone);
   }
   float feedback = Util_dcblock(_ctx.inst_26400, res * _ctx.output);
   float saturated_input = Saturate_soft_process(feedback + in);
   _ctx.output = in + Rescomb_delay(_ctx.inst_3a900, saturated_input, cv) * _ctx.stone;
   return Saturate_soft_process(_ctx.output);
}

static_inline float Rescomb_process(Rescomb_process_type& _ctx, float in, float cv, float tone, float res) {
   return Rescomb_do(_ctx.inst_100b6, in, cv, tone, res);
}

static_inline void Rescomb_noteOn(Rescomb_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Rescomb_noteOff(Rescomb_process_type& _ctx, int32_t note, int32_t channel) {
}

static_inline void Rescomb_controlChange(Rescomb_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
}

static_inline void Rescomb_default(Rescomb_process_type& _ctx) {
}


#endif // RESCOMB_H
