/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "rescomb.h"

void Rescomb_delay_type_init(Rescomb_delay_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 675) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0.0f;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

void Rescomb_do_type_init(Rescomb_do_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b000);
   Util_dcblock_type_init(_ctx.inst_26400);
   Rescomb_delay_type_init(_ctx.inst_3a900);
   _ctx.output = 0.0f;
   _ctx.stone = 0.0f;
}

float Rescomb_delay(Rescomb_delay_type& _ctx, float x, float cv) {
   _ctx.write_pos = (1 + _ctx.write_pos) % 675;
   _ctx.buffer[static_cast<uint32_t>(_ctx.write_pos)] = x;
   float r_size = 675.0f;
   float r_index = fmodf(((- Util_cvToperiod(cv)) + int_to_float(_ctx.write_pos)), r_size);
   if (r_index < 0.0f) {
      r_index = r_index + r_size;
   }
   else {
      r_index = r_index;
   }
   int32_t t1 = float_to_int(floorf(r_index)) % 675;
   int32_t t2 = (1 + t1) % 675;
   float decimal = r_index + (- int_to_float(t1));
   float x1 = _ctx.buffer[static_cast<uint32_t>(t1)];
   float x2 = _ctx.buffer[static_cast<uint32_t>(t2)];
   float ret = x1 + decimal * (x2 + (- x1));
   return ret;
}

float Rescomb_do(Rescomb_do_type& _ctx, float in, float cv, float tone, float res) {
   if (Util_change(_ctx.inst_1b000, tone)) {
      _ctx.stone = Rescomb_toneCurve(tone);
   }
   float feedback = Util_dcblock(_ctx.inst_26400, res * _ctx.output);
   float saturated_input = Saturate_soft_process(feedback + in);
   _ctx.output = in + Rescomb_delay(_ctx.inst_3a900, saturated_input, cv) * _ctx.stone;
   return Saturate_soft_process(_ctx.output);
}

