/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */
#ifndef SHORT_DELAY_H
#define SHORT_DELAY_H

#include "vultin.h"
#include "short_delay.tables.h"

typedef struct Short_delay_soft_type {
   fix16_t x2;
   fix16_t x3;
   fix16_t x4;
} Short_delay_soft_type;

typedef struct Short_delay_do_type {
   std::array<fix16_t, 22050> buffer;
   int32_t write_pos;
} Short_delay_do_type;

typedef struct Short_delay_process_type {
   Short_delay_soft_type inst_1593b;
   Short_delay_do_type inst_2ba3b;
} Short_delay_process_type;

typedef struct Short_delay_process_type Short_delay_noteOn_type;

typedef struct Short_delay_process_type Short_delay_noteOff_type;

typedef struct Short_delay_process_type Short_delay_controlChange_type;

typedef struct Short_delay_process_type Short_delay_default_type;

static_inline void Short_delay_soft_type_init(Short_delay_soft_type& _ctx) {
   _ctx.x2 = 0x0 /* 0.000000 */;
   _ctx.x3 = 0x0 /* 0.000000 */;
   _ctx.x4 = 0x0 /* 0.000000 */;
}

static_inline void Short_delay_do_type_init(Short_delay_do_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 22050) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0x0 /* 0.000000 */;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

static_inline void Short_delay_process_type_init(Short_delay_process_type& _ctx) {
   Short_delay_soft_type_init(_ctx.inst_1593b);
   Short_delay_do_type_init(_ctx.inst_2ba3b);
}

static_inline void Short_delay_noteOn_type_init(Short_delay_noteOn_type& _ctx) {
   Short_delay_process_type_init(_ctx);
}

static_inline void Short_delay_noteOff_type_init(Short_delay_noteOff_type& _ctx) {
   Short_delay_process_type_init(_ctx);
}

static_inline void Short_delay_controlChange_type_init(Short_delay_controlChange_type& _ctx) {
   Short_delay_process_type_init(_ctx);
}

static_inline void Short_delay_default_type_init(Short_delay_default_type& _ctx) {
   Short_delay_process_type_init(_ctx);
}

static_inline fix16_t Saturate_tanh_table_raw_c0(int32_t index) {
   return Saturate_tanh_table_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Saturate_tanh_table_raw_c1(int32_t index) {
   return Saturate_tanh_table_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Saturate_tanh_table_raw_c2(int32_t index) {
   return Saturate_tanh_table_c2[static_cast<uint32_t>(index)];
}

static_inline fix16_t Saturate_tanh_table(fix16_t x) {
   int32_t index = int_clip(fix_to_int(fix_mul((x - -0x180000 /* -24.000000 */), 0x50000 /* 5.000000 */)), 0, 240);
   return Saturate_tanh_table_c0[static_cast<uint32_t>(index)] + fix_mul(x, (Saturate_tanh_table_c1[static_cast<uint32_t>(index)] + fix_mul(Saturate_tanh_table_c2[static_cast<uint32_t>(index)], x)));
}

static_inline fix16_t Saturate_process(fix16_t x) {
   return Saturate_tanh_table(x);
}

static_inline void Saturate_noteOn(int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Saturate_noteOff(int32_t note, int32_t channel) {
}

static_inline void Saturate_controlChange(int32_t control, int32_t value, int32_t channel) {
}

static_inline void Saturate_default() {
}

static_inline fix16_t Short_delay_soft(Short_delay_soft_type& _ctx, fix16_t x1) {
   fix16_t o = fix_mul(0x4000 /* 0.250000 */, (x1 + _ctx.x2 + _ctx.x3 + _ctx.x4));
   fix16_t _t_temp_0 = x1;
   fix16_t _t_temp_1 = _ctx.x2;
   fix16_t _t_temp_2 = _ctx.x3;
   _ctx.x2 = _t_temp_0;
   _ctx.x3 = _t_temp_1;
   _ctx.x4 = _t_temp_2;
   return o;
}

fix16_t Short_delay_do(Short_delay_do_type& _ctx, fix16_t x, fix16_t time, fix16_t feedback);

static_inline fix16_t Short_delay_process(Short_delay_process_type& _ctx, fix16_t x, fix16_t time, fix16_t feedback) {
   return Short_delay_do(_ctx.inst_2ba3b, x, Short_delay_soft(_ctx.inst_1593b, time), feedback);
}

static_inline void Short_delay_noteOn(Short_delay_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Short_delay_noteOff(Short_delay_process_type& _ctx, int32_t note, int32_t channel) {
}

static_inline void Short_delay_controlChange(Short_delay_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
}

static_inline void Short_delay_default(Short_delay_process_type& _ctx) {
}


#endif // SHORT_DELAY_H
