
/* Code automatically generated by Vult https://github.com/modlfo/vult */
#include "blit.h"

void Util__ctx_type_3_init(Util__ctx_type_3 &_output_){
   Util__ctx_type_3 _ctx;
   _ctx.y1 = 0x0 /* 0.000000 */;
   _ctx.x1 = 0x0 /* 0.000000 */;
   _output_ = _ctx;
   return ;
}

fix16_t Util_dcblock(Util__ctx_type_3 &_ctx, fix16_t x0){
   fix16_t y0;
   y0 = (x0 + (- _ctx.x1) + fix_mul(0xfeb8 /* 0.995000 */,_ctx.y1));
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

void Phase__ctx_type_0_init(Phase__ctx_type_0 &_output_){
   Phase__ctx_type_0 _ctx;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.phase = 0x0 /* 0.000000 */;
   Util__ctx_type_0_init(_ctx._inst381);
   Util__ctx_type_1_init(_ctx._inst159);
   Phase_default(_ctx);
   _output_ = _ctx;
   return ;
}

fix16_t Phase_process(Phase__ctx_type_0 &_ctx, fix16_t cv, fix16_t reset){
   if(Util_change(_ctx._inst159,cv)){
      _ctx.rate = Util_cvToRate_1024(cv);
   }
   if(Util_edge(_ctx._inst381,(reset > 0x8000 /* 0.500000 */))){
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else
   {
      _ctx.phase = (_ctx.phase + _ctx.rate);
   }
   if(_ctx.phase > 0x4000000 /* 1024.000000 */){
      _ctx.phase = (-0x4000000 /* -1024.000000 */ + _ctx.phase);
   }
   return (_ctx.phase >> 10);
}

void Blit__ctx_type_0_init(Blit__ctx_type_0 &_output_){
   Blit__ctx_type_0 _ctx;
   _ctx.scale = 0x0 /* 0.000000 */;
   _ctx.m = 0;
   Util__ctx_type_1_init(_ctx._inst159);
   Blit_pulse_start(_ctx);
   _output_ = _ctx;
   return ;
}

fix16_t Blit_pulse_train(Blit__ctx_type_0 &_ctx, fix16_t cv, fix16_t phase){
   if(Util_change(_ctx._inst159,cv)){
      _ctx.m = (1 + (fix_to_int(Util_cvToperiod(cv)) << 1));
      _ctx.scale = (Util_cvToperiod(cv) << 1);
   }
   fix16_t pi_phase;
   pi_phase = (phase >> 1);
   fix16_t denominator;
   denominator = Tables_nsine(pi_phase);
   fix16_t out;
   out = 0x0 /* 0.000000 */;
   if(denominator <= 0x0 /* 0.000000 */){
      out = 0x10000 /* 1.000000 */;
   }
   else
   {
      fix16_t m_phase;
      m_phase = (fix_mul(pi_phase,int_to_fix(_ctx.m)) % 0x10000 /* 1.000000 */);
      fix16_t numerator;
      numerator = Tables_nsine(m_phase);
      out = fix_div(numerator,fix_mul(_ctx.scale,denominator));
   }
   return out;
}

void Blit__ctx_type_1_init(Blit__ctx_type_1 &_output_){
   Blit__ctx_type_1 _ctx;
   _ctx.state_saw = 0x0 /* 0.000000 */;
   _ctx.state_pulse = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.output = 0x0 /* 0.000000 */;
   Blit__ctx_type_0_init(_ctx._inst870);
   Blit__ctx_type_0_init(_ctx._inst770);
   Phase__ctx_type_0_init(_ctx._inst5205);
   Util__ctx_type_1_init(_ctx._inst359);
   Util__ctx_type_3_init(_ctx._inst11125);
   Blit_init(_ctx);
   _output_ = _ctx;
   return ;
}

fix16_t Blit_osc_blit(Blit__ctx_type_1 &_ctx, fix16_t cv, fix16_t pw, fix16_t wave){
   fix16_t fixed_cv;
   fixed_cv = 0x0 /* 0.000000 */;
   if(wave < 0x10000 /* 1.000000 */){
      fixed_cv = cv;
   }
   else
   {
      fixed_cv = (-0x1999 /* -0.100000 */ + cv);
   }
   if(Util_change(_ctx._inst359,fixed_cv)){
      _ctx.rate = Util_cvToRate(fixed_cv);
   }
   fix16_t phase;
   phase = Phase_process(_ctx._inst5205,fixed_cv,0x0 /* 0.000000 */);
   fix16_t shift05;
   shift05 = (0x8000 /* 0.500000 */ + fix_mul(0x7d70 /* 0.490000 */,pw));
   fix16_t shift;
   shift = (phase + shift05);
   if(shift > 0x10000 /* 1.000000 */){
      shift = (-0x10000 /* -1.000000 */ + shift);
   }
   fix16_t pulse1;
   pulse1 = Blit_pulse_train(_ctx._inst770,fixed_cv,phase);
   fix16_t pulse2;
   pulse2 = Blit_pulse_train(_ctx._inst870,fixed_cv,shift);
   _ctx.state_pulse = (pulse1 + (- pulse2) + fix_mul(0xffdf /* 0.999500 */,_ctx.state_pulse));
   _ctx.state_saw = (fix_mul(0xffdf /* 0.999500 */,_ctx.state_saw) + (fix_div((pulse1 + pulse2 + (- (_ctx.rate << 1))),shift05) >> 1));
   if(wave < 0x10000 /* 1.000000 */){
      _ctx.output = _ctx.state_pulse;
   }
   else
   {
      _ctx.output = (_ctx.state_saw << 1);
   }
   _ctx.output = Util_dcblock(_ctx._inst11125,_ctx.output);
   return _ctx.output;
}


