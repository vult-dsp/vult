/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "blit.h"

void Phase_process_type_init(Phase_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b08a);
   Util_edge_type_init(_ctx.inst_2048a);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   Phase_default(_ctx);
}

void Blit_osc_blit_type_init(Blit_osc_blit_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b026);
   Phase_process_type_init(_ctx.inst_28a26);
   Blit_pulse_train_type_init(_ctx.inst_35e26);
   Blit_pulse_train_type_init(_ctx.inst_45e26);
   Util_dcblock_type_init(_ctx.inst_56426);
   _ctx.output = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.state_pulse = 0x0 /* 0.000000 */;
   _ctx.state_saw = 0x0 /* 0.000000 */;
   Blit_init(_ctx);
}

fix16_t Phase_process(Phase_process_type& _ctx, fix16_t cv, fix16_t reset) {
   if (Util_change(_ctx.inst_1b08a, cv)) {
      _ctx.rate = Util_cvToRate_1024(cv);
   }
   if (Util_edge(_ctx.inst_2048a, reset > 0x8000 /* 0.500000 */)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else {
      _ctx.phase = _ctx.phase + _ctx.rate;
   }
   if (_ctx.phase > 0x4000000 /* 1024.000000 */) {
      _ctx.phase = -0x4000000 /* -1024.000000 */ + _ctx.phase;
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   return fix_mul(0x40 /* 0.000977 */, _ctx.phase);
}

fix16_t Blit_pulse_train(Blit_pulse_train_type& _ctx, fix16_t cv, fix16_t phase) {
   if (Util_change(_ctx.inst_1b05e, cv)) {
      _ctx.m = 1 + 2 * fix_to_int(Util_cvToperiod(cv));
      _ctx.scale = fix_mul(0x20000 /* 2.000000 */, Util_cvToperiod(cv));
   }
   fix16_t pi_phase = fix_mul(0x8000 /* 0.500000 */, phase);
   fix16_t denominator = Tables_nsine(pi_phase);
   fix16_t out = 0x0 /* 0.000000 */;
   if (denominator <= fix_eps()) {
      out = 0x10000 /* 1.000000 */;
   }
   else {
      fix16_t m_phase = fix_mul(pi_phase, int_to_fix(_ctx.m)) % 0x10000 /* 1.000000 */;
      fix16_t numerator = Tables_nsine(m_phase);
      out = fix_div(numerator, fix_mul(denominator, _ctx.scale));
   }
   return out;
}

fix16_t Blit_osc_blit(Blit_osc_blit_type& _ctx, fix16_t cv, fix16_t pw, fix16_t wave) {
   fix16_t fixed_cv = 0x0 /* 0.000000 */;
   if (wave < 0x10000 /* 1.000000 */) {
      fixed_cv = cv;
   }
   else {
      fixed_cv = -0x1999 /* -0.100000 */ + cv;
   }
   if (Util_change(_ctx.inst_1b026, fixed_cv)) {
      _ctx.rate = Util_cvToRate(fixed_cv);
   }
   fix16_t phase = Phase_process(_ctx.inst_28a26, fixed_cv, 0x0 /* 0.000000 */);
   fix16_t shift05 = 0x8000 /* 0.500000 */ + fix_mul(0x7d70 /* 0.490000 */, pw);
   fix16_t shift = phase + shift05;
   if (shift > 0x10000 /* 1.000000 */) {
      shift = -0x10000 /* -1.000000 */ + shift;
   }
   fix16_t pulse1 = Blit_pulse_train(_ctx.inst_35e26, fixed_cv, phase);
   fix16_t pulse2 = Blit_pulse_train(_ctx.inst_45e26, fixed_cv, shift);
   _ctx.state_pulse = pulse1 + (- pulse2) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_pulse);
   _ctx.state_saw = fix_mul(0x8000 /* 0.500000 */, fix_div((pulse1 + pulse2 + fix_mul(-0x20000 /* -2.000000 */, _ctx.rate)), shift05)) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_saw);
   if (wave < 0x10000 /* 1.000000 */) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      _ctx.output = fix_mul(0x20000 /* 2.000000 */, _ctx.state_saw);
   }
   _ctx.output = Util_dcblock(_ctx.inst_56426, _ctx.output);
   return _ctx.output;
}

