/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "synth1.h"

void Synth1_process_type_init(Synth1_process_type& _ctx) {
   _ctx.count = 0;
   _ctx.detune = 0x0 /* 0.000000 */;
   _ctx.gate = 0;
   Synth1_lfo_type_init(_ctx.inst_17d3d);
   Synth1_phasor_type_init(_ctx.inst_2863d);
   Synth1_smooth_type_init(_ctx.inst_3dc3d);
   Synth1_phasor_type_init(_ctx.inst_4863d);
   Synth1_smooth_type_init(_ctx.inst_5dc3d);
   Synth1_smooth_type_init(_ctx.inst_6dc3d);
   _ctx.lfo_amt = 0x0 /* 0.000000 */;
   _ctx.lfo_rate = 0x0 /* 0.000000 */;
   _ctx.n1 = 0;
   _ctx.n2 = 0;
   _ctx.n3 = 0;
   _ctx.n4 = 0;
   _ctx.pitch = 0x0 /* 0.000000 */;
   _ctx.pre_phase1 = 0x0 /* 0.000000 */;
   _ctx.volume = 0x0 /* 0.000000 */;
}

fix16_t Synth1_phasor(Synth1_phasor_type& _ctx, fix16_t pitch, bool reset) {
   if (Synth1_change(_ctx.inst_1be86, pitch)) {
      _ctx.rate = Synth1_pitchToRate(pitch);
   }
   if (reset) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else {
      _ctx.phase = (_ctx.phase + _ctx.rate) % 0x10000 /* 1.000000 */;
   }
   return _ctx.phase;
}

fix16_t Synth1_lfo(Synth1_lfo_type& _ctx, fix16_t f, int32_t gate) {
   fix16_t rate = fix_mul(0xe /* 0.000227 */, f);
   if (Synth1_edge(_ctx.inst_11e7d, gate)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   _ctx.phase = rate + _ctx.phase;
   if (_ctx.phase > 0x10000 /* 1.000000 */) {
      _ctx.phase = -0x10000 /* -1.000000 */ + _ctx.phase;
   }
   return -0x8000 /* -0.500000 */ + fix_sin(fix_mul(0x6487e /* 6.283185 */, _ctx.phase));
}

fix16_t Synth1_process(Synth1_process_type& _ctx, fix16_t input) {
   fix16_t lfo_val = fix_mul(Synth1_lfo(_ctx.inst_17d3d, _ctx.lfo_rate, _ctx.gate), _ctx.lfo_amt);
   fix16_t phase1 = Synth1_phasor(_ctx.inst_2863d, _ctx.pitch, false);
   fix16_t comp = 0x10000 /* 1.000000 */ + (- phase1);
   bool reset = (- phase1) + _ctx.pre_phase1 > 0x8000 /* 0.500000 */;
   _ctx.pre_phase1 = phase1;
   fix16_t phase2 = Synth1_phasor(_ctx.inst_4863d, fix_mul(0x200000 /* 32.000000 */, Synth1_smooth(_ctx.inst_3dc3d, (lfo_val + _ctx.detune))) + _ctx.pitch, reset);
   fix16_t sine = fix_sin(fix_mul(0x6487e /* 6.283185 */, phase2));
   fix16_t gate_value = 0x0 /* 0.000000 */;
   if (_ctx.gate > 0) {
      gate_value = 0x10000 /* 1.000000 */;
   }
   else {
      gate_value = 0x0 /* 0.000000 */;
   }
   return fix_mul(comp, fix_mul(sine, fix_mul(Synth1_smooth(_ctx.inst_5dc3d, _ctx.volume), Synth1_smooth(_ctx.inst_6dc3d, gate_value))));
}

void Synth1_noteOn(Synth1_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
    switch (_ctx.count) {
      case 0:
         {
            _ctx.n1 = note;
            _ctx.pitch = int_to_fix(note);
         }
         break;
      case 1:
         {
            _ctx.n2 = note;
            _ctx.pitch = int_to_fix(note);
         }
         break;
      case 2:
         {
            _ctx.n3 = note;
            _ctx.pitch = int_to_fix(note);
         }
         break;
      case 3:
         {
            _ctx.n4 = note;
            _ctx.pitch = int_to_fix(note);
         }
         break;

   }
   if (_ctx.count <= 4) {
      _ctx.count = 1 + _ctx.count;
   }
   if (_ctx.count > 0) {
      _ctx.gate = 1;
   }
   else {
      _ctx.gate = 0;
   }
}

void Synth1_noteOff(Synth1_process_type& _ctx, int32_t note, int32_t channel) {
   bool found = false;
   if (note == _ctx.n1) {
      int32_t _t_temp_0 = _ctx.n2;
      int32_t _t_temp_1 = _ctx.n3;
      int32_t _t_temp_2 = _ctx.n4;
      _ctx.n1 = _t_temp_0;
      _ctx.n2 = _t_temp_1;
      _ctx.n3 = _t_temp_2;
      found = true;
   }
   else {
      if (note == _ctx.n2) {
         int32_t _t_temp_3 = _ctx.n3;
         int32_t _t_temp_4 = _ctx.n4;
         _ctx.n2 = _t_temp_3;
         _ctx.n3 = _t_temp_4;
         found = true;
      }
      else {
         if (note == _ctx.n3) {
            _ctx.n3 = _ctx.n4;
            found = true;
         }
         else {
            if (note == _ctx.n4) {
               found = true;
            }
         }
      }
   }
   if (found && _ctx.count > 0) {
      _ctx.count = -1 + _ctx.count;
   }
   if (_ctx.count > 0) {
      _ctx.gate = 1;
   }
   else {
      _ctx.gate = 0;
   }
   if (_ctx.count == 1) {
      _ctx.pitch = int_to_fix(_ctx.n1);
   }
   if (_ctx.count == 2) {
      _ctx.pitch = int_to_fix(_ctx.n2);
   }
   if (_ctx.count == 3) {
      _ctx.pitch = int_to_fix(_ctx.n3);
   }
   if (_ctx.count == 4) {
      _ctx.pitch = int_to_fix(_ctx.n4);
   }
}

void Synth1_controlChange(Synth1_process_type& _ctx, int32_t control, fix16_t value, int32_t channel) {
   if (control == 30) {
      _ctx.volume = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 31) {
      _ctx.detune = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 32) {
      _ctx.lfo_rate = fix_mul(0x204 /* 0.007874 */, value);
   }
   if (control == 33) {
      _ctx.lfo_amt = -0x10000 /* -1.000000 */ + fix_mul(0x408 /* 0.015748 */, fix_to_fix(value));
   }
}

void Synth1_default(Synth1_process_type& _ctx) {
   _ctx.volume = 0x10000 /* 1.000000 */;
   _ctx.pitch = 0x2d0000 /* 45.000000 */;
   _ctx.detune = 0xcccc /* 0.800000 */;
   _ctx.lfo_rate = 0x11eb /* 0.070000 */;
   _ctx.lfo_amt = -0xcccc /* -0.800000 */;
}

