/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "short_delay.h"

void Short_delay_do_type_init(Short_delay_do_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 22050) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0x0 /* 0.000000 */;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

fix16_t Short_delay_soft(Short_delay_soft_type& _ctx, fix16_t x1) {
   fix16_t o = ((x1 + _ctx.x2 + _ctx.x3 + _ctx.x4) >> 2);
   fix16_t _t_temp_0 = x1;
   fix16_t _t_temp_1 = _ctx.x2;
   fix16_t _t_temp_2 = _ctx.x3;
   _ctx.x2 = _t_temp_0;
   _ctx.x3 = _t_temp_1;
   _ctx.x4 = _t_temp_2;
   return o;
}

fix16_t Short_delay_do(Short_delay_do_type& _ctx, fix16_t x, fix16_t time, fix16_t feedback) {
   time = fix_clip(time, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   feedback = fix_clip(feedback, 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   fix16_t index_r = fix_mul(0x56220000 /* 22050.000000 */, time);
   int32_t index_i = fix_to_int(fix_floor(index_r));
   int32_t delta = (- index_i) + _ctx.write_pos;
   int32_t read_pos = 0;
   if (delta < 0) {
      read_pos = 22050 + delta;
   }
   else {
      read_pos = delta;
   }
   fix16_t decimal = index_r + (- int_to_fix(index_i));
   fix16_t x1 = _ctx.buffer[static_cast<uint32_t>(read_pos)];
   fix16_t x2 = _ctx.buffer[static_cast<uint32_t>((1 + read_pos) % 22050)];
   fix16_t ret = x1 + fix_mul(decimal, x2 + (- x1));
   _ctx.write_pos = (1 + _ctx.write_pos) % 22050;
   _ctx.buffer[static_cast<uint32_t>(_ctx.write_pos)] = Saturate_process(x + fix_mul(feedback, ret));
   return ret;
}

