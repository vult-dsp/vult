/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef SYNTH1_H
#define SYNTH1_H

#include "vultin.h"
#include "synth1.tables.h"

typedef struct Synth1_smooth_type {
   fix16_t x;
} Synth1_smooth_type;

typedef struct Synth1_change_type {
   fix16_t pre_x;
} Synth1_change_type;

typedef struct Synth1_edge_type {
   int32_t pre_x;
} Synth1_edge_type;

typedef struct Synth1_each_type {
   int32_t count;
} Synth1_each_type;

typedef struct Synth1_phasor_type {
   Synth1_change_type inst_1be86;
   fix16_t phase;
   fix16_t rate;
} Synth1_phasor_type;

typedef struct Synth1_lfo_type {
   Synth1_edge_type inst_11e7d;
   fix16_t phase;
} Synth1_lfo_type;

typedef struct Synth1_process_type {
   int32_t count;
   fix16_t detune;
   int32_t gate;
   Synth1_lfo_type inst_17d3d;
   Synth1_phasor_type inst_2863d;
   Synth1_smooth_type inst_3dc3d;
   Synth1_phasor_type inst_4863d;
   Synth1_smooth_type inst_5dc3d;
   Synth1_smooth_type inst_6dc3d;
   fix16_t lfo_amt;
   fix16_t lfo_rate;
   int32_t n1;
   int32_t n2;
   int32_t n3;
   int32_t n4;
   fix16_t pitch;
   fix16_t pre_phase1;
   fix16_t volume;
} Synth1_process_type;

static_inline void Synth1_smooth_type_init(Synth1_smooth_type& _ctx) {
   _ctx.x = 0x0 /* 0.000000 */;
}

static_inline void Synth1_change_type_init(Synth1_change_type& _ctx) {
   _ctx.pre_x = 0x0 /* 0.000000 */;
}

static_inline void Synth1_edge_type_init(Synth1_edge_type& _ctx) {
   _ctx.pre_x = 0;
}

static_inline void Synth1_each_type_init(Synth1_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Synth1_phasor_type_init(Synth1_phasor_type& _ctx) {
   Synth1_change_type_init(_ctx.inst_1be86);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
}

static_inline void Synth1_lfo_type_init(Synth1_lfo_type& _ctx) {
   Synth1_edge_type_init(_ctx.inst_11e7d);
   _ctx.phase = 0x0 /* 0.000000 */;
}

void Synth1_process_type_init(Synth1_process_type& _ctx);

static_inline fix16_t Synth1_smooth(Synth1_smooth_type& _ctx, fix16_t input) {
   _ctx.x = (fix_mul(0x147 /* 0.005000 */, (input + (- _ctx.x))) + _ctx.x);
   return _ctx.x;
}

static_inline bool Synth1_change(Synth1_change_type& _ctx, fix16_t x) {
   bool v = (_ctx.pre_x != x);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth1_edge(Synth1_edge_type& _ctx, int32_t x) {
   bool v = ((_ctx.pre_x != x) && (_ctx.pre_x == 0));
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth1_each(Synth1_each_type& _ctx, int32_t n) {
   bool ret = (_ctx.count == 0);
   _ctx.count = ((1 + _ctx.count) % n);
   return ret;
}

static_inline fix16_t Synth1_pitchToRate(fix16_t d) {
   return fix_mul(0xc /* 0.000185 */, fix_exp(fix_mul(0xec9 /* 0.057762 */, d)));
}

fix16_t Synth1_phasor(Synth1_phasor_type& _ctx, fix16_t pitch, bool reset);

fix16_t Synth1_lfo(Synth1_lfo_type& _ctx, fix16_t f, int32_t gate);

static_inline fix16_t Synth1_process(Synth1_process_type& _ctx, fix16_t input) {
   fix16_t lfo_val = fix_mul(Synth1_lfo(_ctx.inst_17d3d, _ctx.lfo_rate, _ctx.gate), _ctx.lfo_amt);
   fix16_t phase1 = Synth1_phasor(_ctx.inst_2863d, _ctx.pitch, false);
   fix16_t comp = (0x10000 /* 1.000000 */ + (- phase1));
   bool reset = (((- phase1) + _ctx.pre_phase1) > 0x8000 /* 0.500000 */);
   _ctx.pre_phase1 = phase1;
   fix16_t phase2 = Synth1_phasor(_ctx.inst_4863d, (fix_mul(0x200000 /* 32.000000 */, Synth1_smooth(_ctx.inst_3dc3d, (lfo_val + _ctx.detune))) + _ctx.pitch), reset);
   fix16_t sine = fix_sin(fix_mul(0x6487e /* 6.283185 */, phase2));
   fix16_t gate_value = 0.0f;
   if (_ctx.gate > 0) {
      gate_value = 0x10000 /* 1.000000 */;
   }
   else {
      gate_value = 0x0 /* 0.000000 */;
   }
   return fix_mul(comp, fix_mul(sine, fix_mul(Synth1_smooth(_ctx.inst_5dc3d, _ctx.volume), Synth1_smooth(_ctx.inst_6dc3d, gate_value))));
}

void Synth1_noteOn(Synth1_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel);

void Synth1_noteOff(Synth1_process_type& _ctx, int32_t note, int32_t channel);

void Synth1_controlChange(Synth1_process_type& _ctx, int32_t control, fix16_t value, int32_t channel);

void Synth1_default(Synth1_process_type& _ctx);


#endif // SYNTH1_H
