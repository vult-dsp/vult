/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "short_delay.h"

void Short_delay_do_type_init(Short_delay_do_type& _ctx) {
   int32_t i_0 = 0;
   while (i_0 < 22050) {
      _ctx.buffer[static_cast<uint32_t>(i_0)] = 0.0f;
      i_0 = 1 + i_0;
   }
   _ctx.write_pos = 0;
}

float Short_delay_soft(Short_delay_soft_type& _ctx, float x1) {
   float o = 0.25f * (x1 + _ctx.x2 + _ctx.x3 + _ctx.x4);
   float _t_temp_0 = x1;
   float _t_temp_1 = _ctx.x2;
   float _t_temp_2 = _ctx.x3;
   _ctx.x2 = _t_temp_0;
   _ctx.x3 = _t_temp_1;
   _ctx.x4 = _t_temp_2;
   return o;
}

float Short_delay_do(Short_delay_do_type& _ctx, float x, float time, float feedback) {
   time = float_clip(time, 0.0f, 1.0f);
   feedback = float_clip(feedback, 0.0f, 1.0f);
   float index_r = 22050.0f * time;
   int32_t index_i = float_to_int(floorf(index_r));
   int32_t delta = (- index_i) + _ctx.write_pos;
   int32_t read_pos = 0;
   if (delta < 0) {
      read_pos = 22050 + delta;
   }
   else {
      read_pos = delta;
   }
   float decimal = index_r + (- int_to_float(index_i));
   float x1 = _ctx.buffer[static_cast<uint32_t>(read_pos)];
   float x2 = _ctx.buffer[static_cast<uint32_t>((1 + read_pos) % 22050)];
   float ret = x1 + decimal * (x2 + (- x1));
   _ctx.write_pos = (1 + _ctx.write_pos) % 22050;
   _ctx.buffer[static_cast<uint32_t>(_ctx.write_pos)] = Saturate_process(x + feedback * ret);
   return ret;
}

