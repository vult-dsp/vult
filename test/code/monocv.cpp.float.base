/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "monocv.h"

void Monocv_mono_noteOn_type_init(Monocv_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while (i_0 < 4) {
      _ctx.notes[static_cast<uint32_t>(i_0)] = 0;
      i_0 = 1 + i_0;
   }
   _ctx.pre = 0;
}

void Monocv_process_type_init(Monocv_process_type& _ctx) {
   _ctx.Monocv_process_ret_0 = 0.0f;
   _ctx.Monocv_process_ret_1 = 0.0f;
   _ctx.Monocv_process_ret_2 = 0.0f;
   _ctx.active_note = 0;
   _ctx.channel_in = 0;
   _ctx.cv = 0.0f;
   _ctx.gate = 0.0f;
   Util_change_type_init(_ctx.inst_1b0d6);
   Monocv_mono_noteOn_type_init(_ctx.notes);
   _ctx.vel = 0.0f;
}

int32_t Monocv_mono_noteOn(Monocv_mono_noteOn_type& _ctx, int32_t n) {
   if (_ctx.count < 4) {
      _ctx.notes[static_cast<uint32_t>(_ctx.count)] = n;
      _ctx.pre = n;
      if (_ctx.count < 4) {
         _ctx.count = 1 + _ctx.count;
      }
   }
   return _ctx.pre;
}

int32_t Monocv_mono_noteOff(Monocv_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while (i < 4 && found == false) {
      if (_ctx.notes[static_cast<uint32_t>(i)] == n) {
         pos = i;
         found = true;
      }
      i = 1 + i;
   }
   if (found) {
      int32_t k = 1 + pos;
      while (k < 4) {
         _ctx.notes[static_cast<uint32_t>(-1 + k)] = _ctx.notes[static_cast<uint32_t>(k)];
         k = 1 + k;
      }
      if (found && _ctx.count > 0) {
         _ctx.count = -1 + _ctx.count;
         _ctx.pre = _ctx.notes[static_cast<uint32_t>(-1 + _ctx.count)];
      }
   }
   return _ctx.pre;
}

void Monocv_process(Monocv_process_type& _ctx, int32_t c) {
   _ctx.channel_in = c;
   if (Monocv_mono_isGateOn(_ctx.notes)) {
      _ctx.gate = _ctx.vel;
   }
   else {
      _ctx.gate = 0.0f;
   }
   float note = int_to_float(_ctx.active_note);
   if (Util_change(_ctx.inst_1b0d6, note)) {
      _ctx.cv = Util_pitchToCv(note);
   }
   _ctx.Monocv_process_ret_0 = _ctx.cv;
   _ctx.Monocv_process_ret_1 = _ctx.vel;
   _ctx.Monocv_process_ret_2 = _ctx.gate;
   return ;
}

void Monocv_noteOn(Monocv_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   if (_ctx.channel_in == channel) {
      if (velocity > 0) {
         _ctx.active_note = Monocv_mono_noteOn(_ctx.notes, note);
         _ctx.vel = 0.0078741f * int_to_float(velocity);
      }
      else {
         _ctx.active_note = Monocv_mono_noteOff(_ctx.notes, note);
      }
   }
}

