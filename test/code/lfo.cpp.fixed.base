/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "lfo.h"

void Lfo_process_type_init(Lfo_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b0d6);
   Util_edge_type_init(_ctx.inst_204d6);
   Lfo_soft_type_init(_ctx.inst_337d6);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
}

fix16_t Lfo_process(Lfo_process_type& _ctx, fix16_t cv, fix16_t shape, fix16_t reset) {
   if (Util_change(_ctx.inst_1b0d6, cv)) {
      _ctx.rate = Util_cvToRate((-0x4ccc /* -0.300000 */ + cv));
   }
   _ctx.phase = (_ctx.phase + _ctx.rate);
   if ((_ctx.phase > 0x20000 /* 2.000000 */)) {
      _ctx.phase = (-0x20000 /* -2.000000 */ + _ctx.phase);
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   bool breset = (reset > 0x0 /* 0.000000 */);
   if (Util_edge(_ctx.inst_204d6, breset)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   fix16_t tmp = (-0x10000 /* -1.000000 */ + _ctx.phase);
   fix16_t o = 0.0f;
   if ((shape < 0x10000 /* 1.000000 */)) {
      o = tmp;
   }
   else {
      if ((shape < 0x20000 /* 2.000000 */)) {
         o = (-0x10000 /* -1.000000 */ + fix_mul(0x20000 /* 2.000000 */, fix_abs(tmp)));
      }
      else {
         if ((tmp > 0x0 /* 0.000000 */)) {
            o = 0x10000 /* 1.000000 */;
         }
         else {
            o = 0x0 /* 0.000000 */;
         }
      }
   }
   return Lfo_soft(_ctx.inst_337d6, o);
}

