/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "voice_4.h"

void Tricore_process_type_init(Tricore_process_type& _ctx) {
   _ctx.direction = false;
   Util_change_type_init(_ctx.inst_1b03c);
   Util_edge_type_init(_ctx.inst_2043c);
   Util_edge_type_init(_ctx.inst_3043c);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.reset_phase = 0x0 /* 0.000000 */;
   _ctx.reset_state = false;
   Tricore_default(_ctx);
}

void Svf_process_type_init(Svf_process_type& _ctx) {
   _ctx.g = 0x0 /* 0.000000 */;
   Util_change_type_init(_ctx.inst_1b0a2);
   Util_change_type_init(_ctx.inst_2b0a2);
   _ctx.inv_den = 0x0 /* 0.000000 */;
   _ctx.r = 0x0 /* 0.000000 */;
   _ctx.z1 = 0x0 /* 0.000000 */;
   _ctx.z2 = 0x0 /* 0.000000 */;
   Svf_default(_ctx);
}

void Lfo_process_type_init(Lfo_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b0d6);
   Util_edge_type_init(_ctx.inst_204d6);
   Lfo_soft_type_init(_ctx.inst_337d6);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
}

void Phase_process_type_init(Phase_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b08a);
   Util_edge_type_init(_ctx.inst_2048a);
   _ctx.phase = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   Phase_default(_ctx);
}

void Blit_osc_blit_type_init(Blit_osc_blit_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b026);
   Phase_process_type_init(_ctx.inst_28a26);
   Blit_pulse_train_type_init(_ctx.inst_35e26);
   Blit_pulse_train_type_init(_ctx.inst_45e26);
   Util_dcblock_type_init(_ctx.inst_56426);
   _ctx.output = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.state_pulse = 0x0 /* 0.000000 */;
   _ctx.state_saw = 0x0 /* 0.000000 */;
   Blit_init(_ctx);
}

void Adsr_do_type_init(Adsr_do_type& _ctx) {
   Util_edge_type_init(_ctx.inst_104a0);
   Util_smooth_type_init(_ctx.inst_295a0);
   _ctx.out = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.scale = 0x0 /* 0.000000 */;
   _ctx.state = 0;
   _ctx.target = 0x0 /* 0.000000 */;
}

void Adsr_process_type_init(Adsr_process_type& _ctx) {
   Adsr_do_type_init(_ctx.inst_1a025);
   _ctx.knob1 = 0x0 /* 0.000000 */;
   _ctx.knob2 = 0x0 /* 0.000000 */;
   _ctx.knob3 = 0x0 /* 0.000000 */;
   _ctx.knob4 = 0x0 /* 0.000000 */;
}

void Voice_4_process_type_init(Voice_4_process_type& _ctx) {
   _ctx.attack = 0x0 /* 0.000000 */;
   _ctx.decay = 0x0 /* 0.000000 */;
   _ctx.flt_cut = 0x0 /* 0.000000 */;
   _ctx.flt_res = 0x0 /* 0.000000 */;
   _ctx.flt_shape = 0;
   Lfo_process_type_init(_ctx.inst_1d695);
   Blit_process_type_init(_ctx.inst_28b95);
   Blit_process_type_init(_ctx.inst_38b95);
   Blit_process_type_init(_ctx.inst_48b95);
   Tricore_process_type_init(_ctx.inst_53c95);
   Svf_process_type_init(_ctx.inst_6a295);
   Adsr_do_type_init(_ctx.inst_7a095);
   _ctx.level1 = 0x0 /* 0.000000 */;
   _ctx.level2 = 0x0 /* 0.000000 */;
   _ctx.level3 = 0x0 /* 0.000000 */;
   _ctx.level4 = 0x0 /* 0.000000 */;
   _ctx.lfo_cv = 0x0 /* 0.000000 */;
   _ctx.lfo_flt = 0x0 /* 0.000000 */;
   _ctx.lfo_pw = 0x0 /* 0.000000 */;
   _ctx.lfo_rate = 0x0 /* 0.000000 */;
   _ctx.lfo_reset = 0x0 /* 0.000000 */;
   _ctx.lfo_shape = 0x0 /* 0.000000 */;
   _ctx.pw1 = 0x0 /* 0.000000 */;
   _ctx.pw2 = 0x0 /* 0.000000 */;
   _ctx.pw3 = 0x0 /* 0.000000 */;
   _ctx.pw4 = 0x0 /* 0.000000 */;
   _ctx.release = 0x0 /* 0.000000 */;
   _ctx.sustain = 0x0 /* 0.000000 */;
}

fix16_t Tricore_process(Tricore_process_type& _ctx, fix16_t cv, fix16_t reset, fix16_t disable) {
   fix16_t out = 0x0 /* 0.000000 */;
   if (Util_change(_ctx.inst_1b03c, cv)) {
      _ctx.rate = fix_mul(0x40000 /* 4.000000 */, Util_cvToRate_1024(cv));
   }
   fix16_t new_phase = 0.0f;
   fix16_t _if_temp_0 = 0.0f;
   if (_ctx.direction) {
      _if_temp_0 = _ctx.rate;
   }
   else {
      _if_temp_0 = (- _ctx.rate);
   }
   new_phase = _if_temp_0 + _ctx.phase;
   bool bdisable = disable > 0x8000 /* 0.500000 */;
   if (Util_edge(_ctx.inst_2043c, reset > 0x0 /* 0.000000 */) || Util_edge(_ctx.inst_3043c, bdisable)) {
      _ctx.reset_phase = _ctx.phase;
      _ctx.reset_state = true;
      new_phase = 0x0 /* 0.000000 */;
   }
   if (new_phase > 0x4000000 /* 1024.000000 */) {
      new_phase = 0x8000000 /* 2048.000000 */ + (- new_phase);
      _ctx.direction = false;
   }
   else {
      if (new_phase < -0x4000000 /* -1024.000000 */) {
         _ctx.direction = true;
         new_phase = 0x0 /* 0.000000 */ + new_phase;
      }
   }
   if (bdisable) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else {
      _ctx.phase = new_phase;
   }
   if (_ctx.reset_state) {
      if (fix_abs(_ctx.reset_phase) > 0xa0000 /* 10.000000 */ || bdisable) {
         fix16_t reset_speed = 0.0f;
         if (bdisable) {
            reset_speed = 0x28f /* 0.010000 */;
         }
         else {
            reset_speed = 0x8000 /* 0.500000 */;
         }
         _ctx.reset_phase = (- fix_mul(reset_speed, _ctx.reset_phase)) + _ctx.reset_phase;
      }
      else {
         if (_ctx.reset_phase > 0xa0000 /* 10.000000 */) {
            _ctx.reset_phase = _ctx.reset_phase;
         }
         else {
            _ctx.reset_phase = 0x0 /* 0.000000 */;
         }
         _ctx.reset_state = false;
         _ctx.direction = true;
      }
      out = _ctx.reset_phase;
   }
   out = out + _ctx.phase;
   return fix_mul(0x40 /* 0.000977 */, out);
}

fix16_t Svf_process(Svf_process_type& _ctx, fix16_t x, fix16_t cv, fix16_t q, int32_t sel) {
   q = 0x8000 /* 0.500000 */ + q;
   if (Util_change(_ctx.inst_1b0a2, cv) || Util_change(_ctx.inst_2b0a2, q)) {
      _ctx.g = Svf_calc_g(cv);
      _ctx.r = fix_div(0x10000 /* 1.000000 */, fix_mul(0x20000 /* 2.000000 */, (q + fix_eps())));
      _ctx.inv_den = fix_div(0x10000 /* 1.000000 */, (0x10000 /* 1.000000 */ + fix_mul(0x20000 /* 2.000000 */, fix_mul(_ctx.r, _ctx.g)) + fix_mul(_ctx.g, _ctx.g)));
   }
   fix16_t high = fix_mul((x + (- fix_mul((fix_mul(0x20000 /* 2.000000 */, _ctx.r) + _ctx.g), _ctx.z1)) + (- _ctx.z2)), _ctx.inv_den);
   fix16_t band = fix_mul(high, _ctx.g) + _ctx.z1;
   fix16_t low = fix_mul(band, _ctx.g) + _ctx.z2;
   fix16_t notch = high + low;
   _ctx.z1 = band + fix_mul(high, _ctx.g);
   _ctx.z2 = low + fix_mul(band, _ctx.g);
   fix16_t output = 0.0f;
    switch (sel) {
      case 0:
         output = low;
         break;
      case 1:
         output = high;
         break;
      case 2:
         output = band;
         break;
   default:
      output = notch;
      break;
   }
   return Saturate_soft_process(output);
}

fix16_t Lfo_process(Lfo_process_type& _ctx, fix16_t cv, fix16_t shape, fix16_t reset) {
   if (Util_change(_ctx.inst_1b0d6, cv)) {
      _ctx.rate = Util_cvToRate(-0x4ccc /* -0.300000 */ + cv);
   }
   _ctx.phase = _ctx.phase + _ctx.rate;
   if (_ctx.phase > 0x20000 /* 2.000000 */) {
      _ctx.phase = -0x20000 /* -2.000000 */ + _ctx.phase;
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   bool breset = reset > 0x0 /* 0.000000 */;
   if (Util_edge(_ctx.inst_204d6, breset)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   fix16_t tmp = -0x10000 /* -1.000000 */ + _ctx.phase;
   fix16_t o = 0.0f;
   if (shape < 0x10000 /* 1.000000 */) {
      o = tmp;
   }
   else {
      if (shape < 0x20000 /* 2.000000 */) {
         o = -0x10000 /* -1.000000 */ + fix_mul(0x20000 /* 2.000000 */, fix_abs(tmp));
      }
      else {
         if (tmp > 0x0 /* 0.000000 */) {
            o = 0x10000 /* 1.000000 */;
         }
         else {
            o = 0x0 /* 0.000000 */;
         }
      }
   }
   return Lfo_soft(_ctx.inst_337d6, o);
}

fix16_t Phase_process(Phase_process_type& _ctx, fix16_t cv, fix16_t reset) {
   if (Util_change(_ctx.inst_1b08a, cv)) {
      _ctx.rate = Util_cvToRate_1024(cv);
   }
   if (Util_edge(_ctx.inst_2048a, reset > 0x8000 /* 0.500000 */)) {
      _ctx.phase = 0x0 /* 0.000000 */;
   }
   else {
      _ctx.phase = _ctx.phase + _ctx.rate;
   }
   if (_ctx.phase > 0x4000000 /* 1024.000000 */) {
      _ctx.phase = -0x4000000 /* -1024.000000 */ + _ctx.phase;
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   return fix_mul(0x40 /* 0.000977 */, _ctx.phase);
}

fix16_t Blit_pulse_train(Blit_pulse_train_type& _ctx, fix16_t cv, fix16_t phase) {
   if (Util_change(_ctx.inst_1b05e, cv)) {
      _ctx.m = 1 + 2 * fix_to_int(Util_cvToperiod(cv));
      _ctx.scale = fix_mul(0x20000 /* 2.000000 */, Util_cvToperiod(cv));
   }
   fix16_t pi_phase = fix_mul(0x8000 /* 0.500000 */, phase);
   fix16_t denominator = Tables_nsine(pi_phase);
   fix16_t out = 0x0 /* 0.000000 */;
   if (denominator <= fix_eps()) {
      out = 0x10000 /* 1.000000 */;
   }
   else {
      fix16_t m_phase = fix_mul(pi_phase, int_to_fix(_ctx.m)) % 0x10000 /* 1.000000 */;
      fix16_t numerator = Tables_nsine(m_phase);
      out = fix_div(numerator, fix_mul(denominator, _ctx.scale));
   }
   return out;
}

fix16_t Blit_osc_blit(Blit_osc_blit_type& _ctx, fix16_t cv, fix16_t pw, fix16_t wave) {
   fix16_t fixed_cv = 0x0 /* 0.000000 */;
   if (wave < 0x10000 /* 1.000000 */) {
      fixed_cv = cv;
   }
   else {
      fixed_cv = -0x1999 /* -0.100000 */ + cv;
   }
   if (Util_change(_ctx.inst_1b026, fixed_cv)) {
      _ctx.rate = Util_cvToRate(fixed_cv);
   }
   fix16_t phase = Phase_process(_ctx.inst_28a26, fixed_cv, 0x0 /* 0.000000 */);
   fix16_t shift05 = 0x8000 /* 0.500000 */ + fix_mul(0x7d70 /* 0.490000 */, pw);
   fix16_t shift = phase + shift05;
   if (shift > 0x10000 /* 1.000000 */) {
      shift = -0x10000 /* -1.000000 */ + shift;
   }
   fix16_t pulse1 = Blit_pulse_train(_ctx.inst_35e26, fixed_cv, phase);
   fix16_t pulse2 = Blit_pulse_train(_ctx.inst_45e26, fixed_cv, shift);
   _ctx.state_pulse = pulse1 + (- pulse2) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_pulse);
   _ctx.state_saw = fix_mul(0x8000 /* 0.500000 */, fix_div((pulse1 + pulse2 + fix_mul(-0x20000 /* -2.000000 */, _ctx.rate)), shift05)) + fix_mul(0xffdf /* 0.999500 */, _ctx.state_saw);
   if (wave < 0x10000 /* 1.000000 */) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      _ctx.output = fix_mul(0x20000 /* 2.000000 */, _ctx.state_saw);
   }
   _ctx.output = Util_dcblock(_ctx.inst_56426, _ctx.output);
   return _ctx.output;
}

fix16_t Adsr_do(Adsr_do_type& _ctx, fix16_t gate, fix16_t a, fix16_t d, fix16_t s, fix16_t r) {
   fix16_t a_rate = fix_div(0x10000 /* 1.000000 */, (0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, a)));
   fix16_t d_rate = fix_div(0x10000 /* 1.000000 */, (0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, d)));
   fix16_t r_rate = fix_div(0x10000 /* 1.000000 */, (0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, r)));
   _ctx.out = fix_mul(0x106 /* 0.004000 */, fix_mul(((- _ctx.out) + _ctx.target), _ctx.rate)) + _ctx.out;
   bool bgate = gate > 0x0 /* 0.000000 */;
   if (_ctx.state == 0) {
      if (Util_edge(_ctx.inst_104a0, bgate)) {
         _ctx.state = 1;
         _ctx.scale = fix_mul(0x3333 /* 0.200000 */, gate);
      }
      _ctx.rate = r_rate;
      _ctx.target = 0x0 /* 0.000000 */;
   }
   if (_ctx.state == 1) {
      if (bgate == false) {
         _ctx.state = 0;
      }
      if (_ctx.out > 0x4000000 /* 1024.000000 */) {
         _ctx.state = 2;
      }
      _ctx.rate = a_rate;
      _ctx.target = 0x4cccccc /* 1228.800000 */;
   }
   if (_ctx.state == 2) {
      if (bgate == false) {
         _ctx.state = 0;
      }
      _ctx.rate = d_rate;
      _ctx.target = fix_mul(0x4000000 /* 1024.000000 */, s);
   }
   return fix_mul(Util_smooth(_ctx.inst_295a0, _ctx.scale), fix_clip(fix_mul(0x40 /* 0.000977 */, _ctx.out), 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */));
}

void Adsr_controlChange(Adsr_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 1) {
      _ctx.knob1 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 2) {
      _ctx.knob2 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 3) {
      _ctx.knob3 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 4) {
      _ctx.knob4 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
}

void Voice_4_controlChange(Voice_4_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 30) {
      _ctx.level1 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 31) {
      _ctx.level2 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 32) {
      _ctx.level3 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 33) {
      _ctx.level4 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 34) {
      _ctx.pw1 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 35) {
      _ctx.pw2 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 36) {
      _ctx.pw3 = fix_mul(0x33 /* 0.000787 */, int_to_fix(value));
   }
   if (control == 37) {
      _ctx.pw4 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 38) {
      _ctx.lfo_rate = Util_map(int_to_fix(value), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */, -0x6666 /* -0.400000 */, 0x1999 /* 0.100000 */);
   }
   if (control == 39) {
      _ctx.lfo_shape = fix_mul(0x60c /* 0.023622 */, int_to_fix(value));
   }
   if (control == 40) {
      _ctx.lfo_pw = Util_map(int_to_fix(value), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */, -0x10000 /* -1.000000 */, 0x10000 /* 1.000000 */);
   }
   if (control == 41) {
      _ctx.lfo_cv = Util_map(int_to_fix(value), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */, -0x1999 /* -0.100000 */, 0x1999 /* 0.100000 */);
   }
   if (control == 42) {
      _ctx.lfo_flt = Util_map(int_to_fix(value), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */, -0x4ccc /* -0.300000 */, 0x4ccc /* 0.300000 */);
   }
   if (control == 43) {
      if (value > 0) {
         _ctx.lfo_reset = 0x10000 /* 1.000000 */;
      }
      else {
         _ctx.lfo_reset = 0x0 /* 0.000000 */;
      }
   }
   if (control == 44) {
      _ctx.flt_cut = Util_map(int_to_fix(value), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */, -0x3333 /* -0.200000 */, 0x8000 /* 0.500000 */);
   }
   if (control == 45) {
      _ctx.flt_res = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 46) {
      _ctx.flt_shape = 4 * value / 127;
   }
   if (control == 47) {
      _ctx.attack = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 48) {
      _ctx.decay = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 49) {
      _ctx.sustain = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 50) {
      _ctx.release = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
}

