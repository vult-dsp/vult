/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef POLYCV_H
#define POLYCV_H

#include "vultin.h"
#include "polycv.tables.h"

typedef struct Util_edge_type {
   bool pre;
} Util_edge_type;

typedef struct Util_change_type {
   float pre_x;
} Util_change_type;

typedef struct Util_dcblock_type {
   float x1;
   float y1;
} Util_dcblock_type;

typedef struct Util_smooth_type {
   float x;
} Util_smooth_type;

typedef struct Util_average2_type {
   float x0;
} Util_average2_type;

typedef struct Polycv_poly_noteOn_type {
   float Polycv_polyState_ret_0;
   float Polycv_polyState_ret_1;
   float Polycv_polyState_ret_10;
   float Polycv_polyState_ret_11;
   float Polycv_polyState_ret_2;
   float Polycv_polyState_ret_3;
   float Polycv_polyState_ret_4;
   float Polycv_polyState_ret_5;
   float Polycv_polyState_ret_6;
   float Polycv_polyState_ret_7;
   float Polycv_polyState_ret_8;
   float Polycv_polyState_ret_9;
   std::array<int32_t, 4> notes;
   std::array<int32_t, 4> vel;
} Polycv_poly_noteOn_type;

typedef struct Polycv_poly_noteOn_type Polycv_poly_noteOff_type;

typedef struct Polycv_poly_noteOn_type Polycv_polyState_type;

typedef struct Polycv_process_type {
   float Polycv_process_ret_0;
   float Polycv_process_ret_1;
   float Polycv_process_ret_10;
   float Polycv_process_ret_11;
   float Polycv_process_ret_2;
   float Polycv_process_ret_3;
   float Polycv_process_ret_4;
   float Polycv_process_ret_5;
   float Polycv_process_ret_6;
   float Polycv_process_ret_7;
   float Polycv_process_ret_8;
   float Polycv_process_ret_9;
   int32_t channel_in;
   Polycv_poly_noteOn_type poly;
} Polycv_process_type;

typedef struct Polycv_process_type Polycv_noteOn_type;

typedef struct Polycv_process_type Polycv_noteOff_type;

typedef struct Polycv_process_type Polycv_controlChange_type;

typedef struct Polycv_process_type Polycv_default_type;

static_inline void Util_edge_type_init(Util_edge_type& _ctx) {
   _ctx.pre = false;
}

static_inline void Util_change_type_init(Util_change_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

static_inline void Util_dcblock_type_init(Util_dcblock_type& _ctx) {
   _ctx.x1 = 0.0f;
   _ctx.y1 = 0.0f;
}

static_inline void Util_smooth_type_init(Util_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Util_average2_type_init(Util_average2_type& _ctx) {
   _ctx.x0 = 0.0f;
}

void Polycv_poly_noteOn_type_init(Polycv_poly_noteOn_type& _ctx);

static_inline void Polycv_poly_noteOff_type_init(Polycv_poly_noteOff_type& _ctx) {
   Polycv_poly_noteOn_type_init(_ctx);
}

static_inline void Polycv_polyState_type_init(Polycv_polyState_type& _ctx) {
   Polycv_poly_noteOn_type_init(_ctx);
}

void Polycv_process_type_init(Polycv_process_type& _ctx);

static_inline void Polycv_noteOn_type_init(Polycv_noteOn_type& _ctx) {
   Polycv_process_type_init(_ctx);
}

static_inline void Polycv_noteOff_type_init(Polycv_noteOff_type& _ctx) {
   Polycv_process_type_init(_ctx);
}

static_inline void Polycv_controlChange_type_init(Polycv_controlChange_type& _ctx) {
   Polycv_process_type_init(_ctx);
}

static_inline void Polycv_default_type_init(Polycv_default_type& _ctx) {
   Polycv_process_type_init(_ctx);
}

static_inline bool Util_edge(Util_edge_type& _ctx, bool x) {
   bool ret = (x && (_ctx.pre == false));
   _ctx.pre = x;
   return ret;
}

static_inline bool Util_change(Util_change_type& _ctx, float x) {
   bool v = (_ctx.pre_x != x);
   _ctx.pre_x = x;
   return v;
}

static_inline float Util_map(float x, float x0, float x1, float y0, float y1) {
   return (y0 + (((x + (- x0)) * (y1 + (- y0))) / (x1 + (- x0))));
}

static_inline float Util_dcblock(Util_dcblock_type& _ctx, float x0) {
   float y0 = (x0 + ((- _ctx.x1) + (0.995f * _ctx.y1)));
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

static_inline float Util_smooth(Util_smooth_type& _ctx, float input) {
   _ctx.x = ((0.005f * (input + (- _ctx.x))) + _ctx.x);
   return _ctx.x;
}

static_inline float Util_average2(Util_average2_type& _ctx, float x1) {
   float result = (0.5f * (x1 + _ctx.x0));
   _ctx.x0 = x1;
   return result;
}

static_inline float Util_cubic_clipper(float x) {
   if (x <= -0.6666666f) {
      return -0.6666666f;
   }
   else {
      if (x >= 0.6666667f) {
         return 0.6666667f;
      }
      else {
         return (x + (-0.3333333f * (x * (x * x))));
      }
   }
}

static_inline float Util_pitchToRate_1024_raw_c0(int32_t index) {
   return Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024_raw_c1(int32_t index) {
   return Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024_raw_c2(int32_t index) {
   return Util_pitchToRate_1024_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_1024(float pitch) {
   int32_t index = int_clip(float_to_int((pitch * 0.2440945f)), 0, 31);
   return (Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)] + (pitch * (Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)] + (Util_pitchToRate_1024_c2[static_cast<uint32_t>(index)] * pitch))));
}

static_inline float Util_pitchToRate_raw_c0(int32_t index) {
   return Util_pitchToRate_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_raw_c1(int32_t index) {
   return Util_pitchToRate_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate_raw_c2(int32_t index) {
   return Util_pitchToRate_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_pitchToRate(float pitch) {
   int32_t index = int_clip(float_to_int((pitch * 0.2440945f)), 0, 31);
   return (Util_pitchToRate_c0[static_cast<uint32_t>(index)] + (pitch * (Util_pitchToRate_c1[static_cast<uint32_t>(index)] + (Util_pitchToRate_c2[static_cast<uint32_t>(index)] * pitch))));
}

static_inline float Util_cvToPitch(float cv) {
   return (24.0f + (120.0f * cv));
}

static_inline float Util_cvToRate_1024_raw_c0(int32_t index) {
   return Util_cvToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024_raw_c1(int32_t index) {
   return Util_cvToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024_raw_c2(int32_t index) {
   return Util_cvToRate_1024_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_1024(float cv) {
   int32_t index = int_clip(float_to_int((cv * 34.4444445f)), 0, 31);
   return (Util_cvToRate_1024_c0[static_cast<uint32_t>(index)] + (cv * (Util_cvToRate_1024_c1[static_cast<uint32_t>(index)] + (Util_cvToRate_1024_c2[static_cast<uint32_t>(index)] * cv))));
}

static_inline float Util_cvToRate_raw_c0(int32_t index) {
   return Util_cvToRate_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_raw_c1(int32_t index) {
   return Util_cvToRate_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate_raw_c2(int32_t index) {
   return Util_cvToRate_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToRate(float cv) {
   int32_t index = int_clip(float_to_int((cv * 141.1111112f)), 0, 127);
   return (Util_cvToRate_c0[static_cast<uint32_t>(index)] + (cv * (Util_cvToRate_c1[static_cast<uint32_t>(index)] + (Util_cvToRate_c2[static_cast<uint32_t>(index)] * cv))));
}

static_inline float Util_pitchToCv(float pitch) {
   return (0.0083334f * (-24.0f + pitch));
}

static_inline float Util_cvToperiod_raw_c0(int32_t index) {
   return Util_cvToperiod_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod_raw_c1(int32_t index) {
   return Util_cvToperiod_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod_raw_c2(int32_t index) {
   return Util_cvToperiod_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvToperiod(float cv) {
   int32_t index = int_clip(float_to_int((cv * 31.0f)), 0, 31);
   return (Util_cvToperiod_c0[static_cast<uint32_t>(index)] + (cv * (Util_cvToperiod_c1[static_cast<uint32_t>(index)] + (Util_cvToperiod_c2[static_cast<uint32_t>(index)] * cv))));
}

static_inline float Util_cvTokHz_raw_c0(int32_t index) {
   return Util_cvTokHz_c0[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz_raw_c1(int32_t index) {
   return Util_cvTokHz_c1[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz_raw_c2(int32_t index) {
   return Util_cvTokHz_c2[static_cast<uint32_t>(index)];
}

static_inline float Util_cvTokHz(float cv) {
   int32_t index = int_clip(float_to_int((cv * 31.0f)), 0, 31);
   return (Util_cvTokHz_c0[static_cast<uint32_t>(index)] + (cv * (Util_cvTokHz_c1[static_cast<uint32_t>(index)] + (Util_cvTokHz_c2[static_cast<uint32_t>(index)] * cv))));
}

static_inline float Polycv_velToCV(int32_t vel) {
   return (0.0078741f * int_to_float(vel));
}

static_inline float Polycv_velToGate(int32_t vel) {
   if (vel > 0) {
      return (0.0078741f * int_to_float(vel));
   }
   else {
      return 0.0f;
   }
}

void Polycv_poly_noteOn(Polycv_poly_noteOn_type& _ctx, int32_t note, int32_t velocity);

void Polycv_poly_noteOff(Polycv_poly_noteOn_type& _ctx, int32_t note);

void Polycv_polyState(Polycv_poly_noteOn_type& _ctx);

void Polycv_process(Polycv_process_type& _ctx, int32_t c);

static_inline void Polycv_noteOn(Polycv_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   if (_ctx.channel_in == channel) {
      if (velocity > 0) {
         Polycv_poly_noteOn(_ctx.poly, note, velocity);
      }
      else {
         Polycv_poly_noteOff(_ctx.poly, note);
      }
   }
}

static_inline void Polycv_noteOff(Polycv_process_type& _ctx, int32_t note, int32_t channel) {
   if (_ctx.channel_in == channel) {
      Polycv_poly_noteOff(_ctx.poly, note);
   }
}

static_inline void Polycv_controlChange(Polycv_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
}

static_inline void Polycv_default(Polycv_process_type& _ctx) {
}


#endif // POLYCV_H
