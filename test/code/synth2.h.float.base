/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */
#ifndef SYNTH2_H
#define SYNTH2_H

#include "vultin.h"
#include "synth2.tables.h"

typedef struct Synth2_change_type {
   float pre_x;
} Synth2_change_type;

typedef struct Synth2_bchange_type {
   bool pre_x;
} Synth2_bchange_type;

typedef struct Synth2_edge_type {
   bool pre_x;
} Synth2_edge_type;

typedef struct Synth2_each_type {
   int32_t count;
} Synth2_each_type;

typedef struct Synth2_dcblock_type {
   float x1;
   float y1;
} Synth2_dcblock_type;

typedef struct Synth2_smooth_type {
   float x;
} Synth2_smooth_type;

typedef struct Synth2_lpfilter_type {
   float pre_x;
} Synth2_lpfilter_type;

typedef struct Synth2_osc_type {
   Synth2_change_type inst_177e5;
   Synth2_dcblock_type inst_24fe5;
   float m;
   float output;
   float phase;
   float rate;
   float state_pulse;
   float state_saw;
   float state_triang;
} Synth2_osc_type;

typedef struct Synth2_svf_step_type {
   float dband;
   float dlow;
} Synth2_svf_step_type;

typedef struct Synth2_svf_type {
   float g;
   Synth2_change_type inst_177a7;
   Synth2_svf_step_type step;
} Synth2_svf_type;

typedef struct Synth2_lfo_type {
   Synth2_edge_type inst_1445f;
   Synth2_each_type inst_2cb5f;
   float phase;
} Synth2_lfo_type;

typedef struct Synth2_mono_noteOn_type {
   int32_t count;
   std::array<int32_t, 4> notes;
   int32_t pre;
} Synth2_mono_noteOn_type;

typedef struct Synth2_mono_noteOn_type Synth2_mono_noteOff_type;

typedef struct Synth2_mono_noteOn_type Synth2_mono_isGateOn_type;

typedef struct Synth2_process_type {
   float amp_s;
   float cut;
   Synth2_lfo_type inst_15fb7;
   Synth2_osc_type inst_2e5b7;
   Synth2_smooth_type inst_3dfb7;
   Synth2_svf_type inst_4a7b7;
   float lfo_amt;
   float lfo_rate;
   Synth2_mono_noteOn_type monoin;
   float pitch;
   float pw;
   float res;
   float volume;
   float wave;
} Synth2_process_type;

typedef struct Synth2_process_type Synth2_noteOn_type;

typedef struct Synth2_process_type Synth2_noteOff_type;

typedef struct Synth2_process_type Synth2_controlChange_type;

typedef struct Synth2_process_type Synth2_default_type;

static_inline void Synth2_change_type_init(Synth2_change_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

static_inline void Synth2_bchange_type_init(Synth2_bchange_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Synth2_edge_type_init(Synth2_edge_type& _ctx) {
   _ctx.pre_x = false;
}

static_inline void Synth2_each_type_init(Synth2_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Synth2_dcblock_type_init(Synth2_dcblock_type& _ctx) {
   _ctx.x1 = 0.0f;
   _ctx.y1 = 0.0f;
}

static_inline void Synth2_smooth_type_init(Synth2_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Synth2_lpfilter_type_init(Synth2_lpfilter_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

void Synth2_osc_type_init(Synth2_osc_type& _ctx);

static_inline void Synth2_svf_step_type_init(Synth2_svf_step_type& _ctx) {
   _ctx.dband = 0.0f;
   _ctx.dlow = 0.0f;
}

static_inline void Synth2_svf_type_init(Synth2_svf_type& _ctx) {
   _ctx.g = 0.0f;
   Synth2_change_type_init(_ctx.inst_177a7);
   Synth2_svf_step_type_init(_ctx.step);
}

static_inline void Synth2_lfo_type_init(Synth2_lfo_type& _ctx) {
   Synth2_edge_type_init(_ctx.inst_1445f);
   Synth2_each_type_init(_ctx.inst_2cb5f);
   _ctx.phase = 0.0f;
}

void Synth2_mono_noteOn_type_init(Synth2_mono_noteOn_type& _ctx);

static_inline void Synth2_mono_noteOff_type_init(Synth2_mono_noteOff_type& _ctx) {
   Synth2_mono_noteOn_type_init(_ctx);
}

static_inline void Synth2_mono_isGateOn_type_init(Synth2_mono_isGateOn_type& _ctx) {
   Synth2_mono_noteOn_type_init(_ctx);
}

void Synth2_default(Synth2_process_type& _ctx);

void Synth2_process_type_init(Synth2_process_type& _ctx);

static_inline void Synth2_noteOn_type_init(Synth2_noteOn_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_noteOff_type_init(Synth2_noteOff_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_controlChange_type_init(Synth2_controlChange_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline void Synth2_default_type_init(Synth2_default_type& _ctx) {
   Synth2_process_type_init(_ctx);
}

static_inline float Synth2_minFixed() {
   return 2e-05f;
}

static_inline bool Synth2_change(Synth2_change_type& _ctx, float x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_bchange(Synth2_bchange_type& _ctx, bool x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_edge(Synth2_edge_type& _ctx, bool x) {
   bool v = (_ctx.pre_x != x) && (_ctx.pre_x == true);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth2_each(Synth2_each_type& _ctx, int32_t n) {
   bool ret = _ctx.count == 0;
   _ctx.count = (1 + _ctx.count) % n;
   return ret;
}

static_inline bool Synth2_near_zero(float x) {
   return fabsf(x) < 0.02f;
}

static_inline float Synth2_dcblock(Synth2_dcblock_type& _ctx, float x0) {
   float y0 = x0 + (- _ctx.x1) + 0.995f * _ctx.y1;
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

static_inline float Synth2_smooth(Synth2_smooth_type& _ctx, float input) {
   _ctx.x = 0.005f * (input + (- _ctx.x)) + _ctx.x;
   return _ctx.x;
}

static_inline float Synth2_lpfilter(Synth2_lpfilter_type& _ctx, float x) {
   float ret = 0.5f * (x + _ctx.pre_x);
   _ctx.pre_x = x;
   return ret;
}

static_inline float Synth2_pitchToRate(float d) {
   return 0.00019f * expf(0.05777f * d);
}

static_inline float Synth2_pulse_train(float m, float phase) {
   float pi_phase = 3.1416f * phase;
   float denominator1 = sinf(pi_phase);
   float tmp1 = 0.0f;
   if (Synth2_near_zero(denominator1)) {
      tmp1 = 1.0f;
   }
   else {
      tmp1 = sinf(m * pi_phase);
      tmp1 = tmp1 / (denominator1 * m);
   }
   return tmp1;
}

float Synth2_osc(Synth2_osc_type& _ctx, float pitch, float pw, float wave);

float Synth2_svf_step(Synth2_svf_step_type& _ctx, float input, float g, float q, int32_t sel);

static_inline float Synth2_svf(Synth2_svf_type& _ctx, float input, float fc, float q, int32_t sel) {
   fc = float_clip(fc, 0.0f, 1.0f);
   q = float_clip(q, 0.0f, 1.0f);
   float fix_q = 2.0f + 2.0f * (- q);
   if (Synth2_change(_ctx.inst_177a7, fc)) {
      _ctx.g = 0.5f * fc;
   }
   float x1 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   float x2 = Synth2_svf_step(_ctx.step, input, _ctx.g, fix_q, sel);
   return 0.5f * (x1 + x2);
}

float Synth2_lfo(Synth2_lfo_type& _ctx, float f, bool gate);

int32_t Synth2_mono_noteOn(Synth2_mono_noteOn_type& _ctx, int32_t n);

int32_t Synth2_mono_noteOff(Synth2_mono_noteOn_type& _ctx, int32_t n);

static_inline bool Synth2_mono_isGateOn(Synth2_mono_noteOn_type& _ctx) {
   return _ctx.count > 0;
}

static_inline float Synth2_process(Synth2_process_type& _ctx, float i) {
   bool gate = Synth2_mono_isGateOn(_ctx.monoin);
   float lfo1 = Synth2_lfo(_ctx.inst_15fb7, _ctx.lfo_rate, gate) * _ctx.lfo_amt;
   float o1 = Synth2_osc(_ctx.inst_2e5b7, _ctx.pitch, lfo1 + _ctx.pw, _ctx.wave);
   float amp_env = 0.0f;
   float _if_temp_0 = 0.0f;
   if (gate) {
      _if_temp_0 = 1.0f;
   }
   else {
      _if_temp_0 = 0.0f;
   }
   amp_env = Synth2_smooth(_ctx.inst_3dfb7, _if_temp_0);
   float output = amp_env * Synth2_svf(_ctx.inst_4a7b7, o1, _ctx.cut, _ctx.res, 0);
   return output * _ctx.volume;
}

static_inline void Synth2_noteOn(Synth2_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
   _ctx.pitch = int_to_float(Synth2_mono_noteOn(_ctx.monoin, note));
}

static_inline void Synth2_noteOff(Synth2_process_type& _ctx, int32_t note, int32_t channel) {
   _ctx.pitch = int_to_float(Synth2_mono_noteOff(_ctx.monoin, note));
}

void Synth2_controlChange(Synth2_process_type& _ctx, int32_t control, int32_t value, int32_t channel);


#endif // SYNTH2_H
