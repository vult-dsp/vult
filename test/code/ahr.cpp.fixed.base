/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */

#include "ahr.h"

void Ahr_do_type_init(Ahr_do_type& _ctx) {
   _ctx.Ahr_do_ret_0 = 0x0 /* 0.000000 */;
   _ctx.Ahr_do_ret_1 = 0x0 /* 0.000000 */;
   _ctx.hold_phase = 0x0 /* 0.000000 */;
   Util_edge_type_init(_ctx.inst_104d8);
   Util_edge_type_init(_ctx.inst_204d8);
   _ctx.out = 0x0 /* 0.000000 */;
   _ctx.rate = 0x0 /* 0.000000 */;
   _ctx.state = 0;
   _ctx.target = 0x0 /* 0.000000 */;
}

void Ahr_process_type_init(Ahr_process_type& _ctx) {
   _ctx.Ahr_process_ret_0 = 0x0 /* 0.000000 */;
   _ctx.Ahr_process_ret_1 = 0x0 /* 0.000000 */;
   Ahr_do_type_init(_ctx.inst_1d84b);
   _ctx.knob1 = 0x0 /* 0.000000 */;
   _ctx.knob2 = 0x0 /* 0.000000 */;
   _ctx.knob3 = 0x0 /* 0.000000 */;
}

void Ahr_do(Ahr_do_type& _ctx, fix16_t gate, fix16_t a, fix16_t h, fix16_t r) {
   int32_t release = 0;
   int32_t attack = 1;
   int32_t hold = 2;
   int32_t reset = 3;
   bool bgate = gate > 0x0 /* 0.000000 */;
   if (Util_edge(_ctx.inst_104d8, bgate)) {
      _ctx.state = reset;
   }
   fix16_t resetting = 0x0 /* 0.000000 */;
   if (_ctx.state == reset) {
      resetting = 0x10000 /* 1.000000 */;
   }
   else {
      resetting = 0x0 /* 0.000000 */;
   }
   if (Util_edge(_ctx.inst_204d8, _ctx.out > 0x4000000 /* 1024.000000 */)) {
      _ctx.hold_phase = 0x0 /* 0.000000 */;
      _ctx.state = hold;
   }
   if ((_ctx.out < 0xa0000 /* 10.000000 */) && (_ctx.state == reset)) {
      _ctx.state = attack;
   }
   if ((_ctx.hold_phase > 0x640000 /* 100.000000 */) && (_ctx.state == hold)) {
      _ctx.state = release;
   }
   if (_ctx.state == reset) {
      _ctx.rate = 0xfd77 /* 0.990099 */;
      _ctx.target = 0x0 /* 0.000000 */;
   }
   if (_ctx.state == attack) {
      _ctx.rate = fix_div(0x10000 /* 1.000000 */, 0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, a));
      _ctx.target = 0x4cccccc /* 1228.800000 */;
   }
   if (_ctx.state == hold) {
      fix16_t hrate = fix_div(0x10000 /* 1.000000 */, 0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, h));
      _ctx.hold_phase = hrate + _ctx.hold_phase;
   }
   if (_ctx.state == release) {
      _ctx.rate = fix_div(0x10000 /* 1.000000 */, 0x28f /* 0.010000 */ + fix_mul(0x640000 /* 100.000000 */, r));
      _ctx.target = 0x0 /* 0.000000 */;
   }
   _ctx.out = fix_mul(0x147 /* 0.005000 */, fix_mul((- _ctx.out) + _ctx.target, _ctx.rate)) + _ctx.out;
   _ctx.Ahr_do_ret_0 = fix_clip((_ctx.out >> 10), 0x0 /* 0.000000 */, 0x10000 /* 1.000000 */);
   _ctx.Ahr_do_ret_1 = resetting;
   return ;
}

void Ahr_process(Ahr_process_type& _ctx, fix16_t gate) {
   Ahr_do(_ctx.inst_1d84b, gate, _ctx.knob1, _ctx.knob2, _ctx.knob3);
   fix16_t _call_temp_0 = _ctx.inst_1d84b.Ahr_do_ret_0;
   fix16_t _call_temp_1 = _ctx.inst_1d84b.Ahr_do_ret_1;
   _ctx.Ahr_process_ret_0 = _call_temp_0;
   _ctx.Ahr_process_ret_1 = _call_temp_1;
   return ;
}

void Ahr_controlChange(Ahr_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 1) {
      _ctx.knob1 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 2) {
      _ctx.knob2 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
   if (control == 3) {
      _ctx.knob3 = fix_mul(0x204 /* 0.007874 */, int_to_fix(value));
   }
}

