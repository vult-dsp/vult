/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */
#ifndef SYNTH1_H
#define SYNTH1_H

#include "vultin.h"
#include "synth1.tables.h"

typedef struct Synth1_smooth_type {
   float x;
} Synth1_smooth_type;

typedef struct Synth1_change_type {
   float pre_x;
} Synth1_change_type;

typedef struct Synth1_edge_type {
   int32_t pre_x;
} Synth1_edge_type;

typedef struct Synth1_each_type {
   int32_t count;
} Synth1_each_type;

typedef struct Synth1_phasor_type {
   Synth1_change_type inst_1be86;
   float phase;
   float rate;
} Synth1_phasor_type;

typedef struct Synth1_lfo_type {
   Synth1_edge_type inst_11e7d;
   float phase;
} Synth1_lfo_type;

typedef struct Synth1_process_type {
   int32_t count;
   float detune;
   int32_t gate;
   Synth1_lfo_type inst_17d3d;
   Synth1_phasor_type inst_2863d;
   Synth1_smooth_type inst_3dc3d;
   Synth1_phasor_type inst_4863d;
   Synth1_smooth_type inst_5dc3d;
   Synth1_smooth_type inst_6dc3d;
   float lfo_amt;
   float lfo_rate;
   int32_t n1;
   int32_t n2;
   int32_t n3;
   int32_t n4;
   float pitch;
   float pre_phase1;
   float volume;
} Synth1_process_type;

static_inline void Synth1_smooth_type_init(Synth1_smooth_type& _ctx) {
   _ctx.x = 0.0f;
}

static_inline void Synth1_change_type_init(Synth1_change_type& _ctx) {
   _ctx.pre_x = 0.0f;
}

static_inline void Synth1_edge_type_init(Synth1_edge_type& _ctx) {
   _ctx.pre_x = 0;
}

static_inline void Synth1_each_type_init(Synth1_each_type& _ctx) {
   _ctx.count = 0;
}

static_inline void Synth1_phasor_type_init(Synth1_phasor_type& _ctx) {
   Synth1_change_type_init(_ctx.inst_1be86);
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
}

static_inline void Synth1_lfo_type_init(Synth1_lfo_type& _ctx) {
   Synth1_edge_type_init(_ctx.inst_11e7d);
   _ctx.phase = 0.0f;
}

void Synth1_process_type_init(Synth1_process_type& _ctx);

static_inline float Synth1_smooth(Synth1_smooth_type& _ctx, float input) {
   _ctx.x = ((0.005f * (input + (-_ctx.x))) + _ctx.x);
   return _ctx.x;
}

static_inline bool Synth1_change(Synth1_change_type& _ctx, float x) {
   bool v = (_ctx.pre_x != x);
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth1_edge(Synth1_edge_type& _ctx, int32_t x) {
   bool v = ((_ctx.pre_x != x) && (_ctx.pre_x == 0));
   _ctx.pre_x = x;
   return v;
}

static_inline bool Synth1_each(Synth1_each_type& _ctx, int32_t n) {
   bool ret = (_ctx.count == 0);
   _ctx.count = ((1 + _ctx.count) % n);
   return ret;
}

static_inline float Synth1_pitchToRate(float d) {
   return (0.000185392290249f * exp((0.0577623f * d)));
}

float Synth1_phasor(Synth1_phasor_type& _ctx, float pitch, bool reset);

float Synth1_lfo(Synth1_lfo_type& _ctx, float f, int32_t gate);

static_inline float Synth1_process(Synth1_process_type& _ctx, float input) {
   float lfo_val = (Synth1_lfo(_ctx.inst_17d3d, _ctx.lfo_rate, _ctx.gate) * _ctx.lfo_amt);
   float phase1 = Synth1_phasor(_ctx.inst_2863d, _ctx.pitch, false);
   float comp = (1.0f + (-phase1));
   bool reset = (((-phase1) + _ctx.pre_phase1) > 0.5f);
   _ctx.pre_phase1 = phase1;
   float phase2 = Synth1_phasor(_ctx.inst_4863d, ((32.0f * Synth1_smooth(_ctx.inst_3dc3d, (lfo_val + _ctx.detune))) + _ctx.pitch), reset);
   float sine = sin((6.28318530718f * phase2));
   float gate_value = 0.0f;
   if ((_ctx.gate > 0)) {
      gate_value = 1.0f;
   }
   else {
      gate_value = 0.0f;
   }
   return (comp * (sine * (Synth1_smooth(_ctx.inst_5dc3d, _ctx.volume) * Synth1_smooth(_ctx.inst_6dc3d, gate_value))));
}

void Synth1_noteOn(Synth1_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel);

void Synth1_noteOff(Synth1_process_type& _ctx, int32_t note, int32_t channel);

void Synth1_controlChange(Synth1_process_type& _ctx, int32_t control, float value, int32_t channel);

void Synth1_default(Synth1_process_type& _ctx);


#endif // SYNTH1_H
