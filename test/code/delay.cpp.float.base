/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "delay.h"

void Delay_mono_noteOn_type_init(Delay_mono_noteOn_type& _ctx) {
   _ctx.count = 0;
   int32_t i_0 = 0;
   while (i_0 < 4) {
      _ctx.notes[static_cast<uint32_t>(i_0)] = 0;
      i_0 = (1 + i_0);
   }
   _ctx.pre = 0;
}

void Delay_process_type_init(Delay_process_type& _ctx) {
   _ctx.detune = 0.0f;
   _ctx.feedback = 0.0f;
   Delay_lfo_type_init(_ctx.inst_16101);
   Delay_phd_osc_type_init(_ctx.inst_2c401);
   Delay_smooth_type_init(_ctx.inst_37701);
   Delay_smooth_type_init(_ctx.inst_47701);
   Delay_smooth_type_init(_ctx.inst_57701);
   Delay_delay_type_init(_ctx.inst_68e01);
   _ctx.lfo_amt = 0.0f;
   _ctx.lfo_rate = 0.0f;
   Delay_mono_noteOn_type_init(_ctx.notes_5901);
   _ctx.pitch = 0.0f;
   _ctx.time = 0.0f;
   _ctx.volume = 0.0f;
}

float Delay_phasor(Delay_phasor_type& _ctx, float pitch, bool reset) {
   if (Delay_change(_ctx.inst_18071, pitch)) {
      _ctx.rate = Delay_pitchToRate(pitch);
   }
   if (reset) {
      _ctx.phase = 0.0f;
   }
   else {
      _ctx.phase = fmodf((_ctx.phase + _ctx.rate), 1.0f);
   }
   return _ctx.phase;
}

float Delay_lfo(Delay_lfo_type& _ctx, float f, bool gate) {
   float rate = (0.000226757369615f * f);
   if (Delay_edge(_ctx.inst_11461, gate)) {
      _ctx.phase = 0.0f;
   }
   _ctx.phase = (rate + _ctx.phase);
   if (_ctx.phase > 1.0f) {
      _ctx.phase = (-1.0f + _ctx.phase);
   }
   return (-0.5f + sin((6.28318530718f * _ctx.phase)));
}

float Delay_delay(Delay_delay_type& _ctx, float x, float time, float feedback) {
   time = float_clip(time, 0.0f, 1.0f);
   feedback = float_clip(feedback, 0.0f, 1.0f);
   float index_r = (time * int_to_float(30000));
   int32_t index_i = float_to_int(floor(index_r));
   int32_t delta = ((- index_i) + _ctx.write_pos);
   int32_t read_pos = 0;
   if (delta < 0) {
      read_pos = (30000 + delta);
   }
   else {
      read_pos = delta;
   }
   float decimal = (index_r + (- int_to_float(index_i)));
   float x1 = _ctx.buffer[static_cast<uint32_t>(read_pos)];
   float x2 = _ctx.buffer[static_cast<uint32_t>(((1 + read_pos) % 30000))];
   float ret = (x1 + (decimal * (x2 + (- x1))));
   _ctx.write_pos = ((1 + _ctx.write_pos) % 30000);
   _ctx.buffer[static_cast<uint32_t>(_ctx.write_pos)] = float_clip((x + (feedback * ret)), -1.0f, 1.0f);
   return ret;
}

int32_t Delay_mono_noteOn(Delay_mono_noteOn_type& _ctx, int32_t n) {
   if (_ctx.count < 4) {
      _ctx.notes[static_cast<uint32_t>(_ctx.count)] = n;
      _ctx.pre = n;
      if (_ctx.count < 4) {
         _ctx.count = (1 + _ctx.count);
      }
   }
   return _ctx.pre;
}

int32_t Delay_mono_noteOff(Delay_mono_noteOn_type& _ctx, int32_t n) {
   bool found = false;
   int32_t i = 0;
   int32_t pos = 0;
   if (_ctx.count == 0) {
      return _ctx.pre;
   }
   while ((i < 4) && (found == false)) {
      if (_ctx.notes[static_cast<uint32_t>(i)] == n) {
         pos = i;
         found = true;
      }
      i = (1 + i);
   }
   if (found) {
      int32_t k = (1 + pos);
      while (k < 4) {
         _ctx.notes[static_cast<uint32_t>((-1 + k))] = _ctx.notes[static_cast<uint32_t>(k)];
         k = (1 + k);
      }
      if (found && (_ctx.count > 0)) {
         _ctx.count = (-1 + _ctx.count);
         _ctx.pre = _ctx.notes[static_cast<uint32_t>((-1 + _ctx.count))];
      }
   }
   return _ctx.pre;
}

void Delay_controlChange(Delay_process_type& _ctx, int32_t control, float value, int32_t channel) {
   if (control == 30) {
      _ctx.volume = (0.00787401574803f * value);
   }
   if (control == 31) {
      _ctx.detune = (0.00787401574803f * value);
   }
   if (control == 32) {
      _ctx.lfo_rate = (0.00787401574803f * value);
   }
   if (control == 33) {
      _ctx.lfo_amt = (2.0f * (-0.5f + (0.00787401574803f * value)));
   }
   if (control == 34) {
      _ctx.time = (0.00787401574803f * value);
   }
   if (control == 35) {
      _ctx.feedback = (0.00787401574803f * value);
   }
}

void Delay_default(Delay_process_type& _ctx) {
   _ctx.volume = 1.0f;
   _ctx.pitch = 45.0f;
   _ctx.detune = 0.8f;
   _ctx.lfo_rate = 0.07f;
   _ctx.lfo_amt = -0.8f;
   _ctx.time = 0.5f;
   _ctx.feedback = 0.5f;
}

