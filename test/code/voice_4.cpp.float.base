/* This code was generated by the Vult compiler v1-dev https://github.com/modlfo/vult */

#include "voice_4.h"

void Tricore_process_type_init(Tricore_process_type& _ctx) {
   _ctx.direction = false;
   Util_change_type_init(_ctx.inst_1b03c);
   Util_edge_type_init(_ctx.inst_2043c);
   Util_edge_type_init(_ctx.inst_3043c);
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
   _ctx.reset_phase = 0.0f;
   _ctx.reset_state = false;
   Tricore_default(_ctx);
}

void Svf_process_type_init(Svf_process_type& _ctx) {
   _ctx.g = 0.0f;
   Util_change_type_init(_ctx.inst_1b0a2);
   Util_change_type_init(_ctx.inst_2b0a2);
   _ctx.inv_den = 0.0f;
   _ctx.r = 0.0f;
   _ctx.z1 = 0.0f;
   _ctx.z2 = 0.0f;
   Svf_default(_ctx);
}

void Lfo_process_type_init(Lfo_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b0d6);
   Util_edge_type_init(_ctx.inst_204d6);
   Lfo_soft_type_init(_ctx.inst_337d6);
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
}

void Phase_process_type_init(Phase_process_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b08a);
   Util_edge_type_init(_ctx.inst_2048a);
   _ctx.phase = 0.0f;
   _ctx.rate = 0.0f;
   Phase_default(_ctx);
}

void Blit_osc_blit_type_init(Blit_osc_blit_type& _ctx) {
   Util_change_type_init(_ctx.inst_1b026);
   Phase_process_type_init(_ctx.inst_28a26);
   Blit_pulse_train_type_init(_ctx.inst_35e26);
   Blit_pulse_train_type_init(_ctx.inst_45e26);
   Util_dcblock_type_init(_ctx.inst_56426);
   _ctx.output = 0.0f;
   _ctx.rate = 0.0f;
   _ctx.state_pulse = 0.0f;
   _ctx.state_saw = 0.0f;
   Blit_init(_ctx);
}

void Adsr_do_type_init(Adsr_do_type& _ctx) {
   Util_edge_type_init(_ctx.inst_104a0);
   Util_smooth_type_init(_ctx.inst_295a0);
   _ctx.out = 0.0f;
   _ctx.rate = 0.0f;
   _ctx.scale = 0.0f;
   _ctx.state = 0;
   _ctx.target = 0.0f;
}

void Adsr_process_type_init(Adsr_process_type& _ctx) {
   Adsr_do_type_init(_ctx.inst_1a025);
   _ctx.knob1 = 0.0f;
   _ctx.knob2 = 0.0f;
   _ctx.knob3 = 0.0f;
   _ctx.knob4 = 0.0f;
}

void Voice_4_process_type_init(Voice_4_process_type& _ctx) {
   _ctx.attack = 0.0f;
   _ctx.decay = 0.0f;
   _ctx.flt_cut = 0.0f;
   _ctx.flt_res = 0.0f;
   _ctx.flt_shape = 0;
   Lfo_process_type_init(_ctx.inst_1d695);
   Blit_process_type_init(_ctx.inst_28b95);
   Blit_process_type_init(_ctx.inst_38b95);
   Blit_process_type_init(_ctx.inst_48b95);
   Tricore_process_type_init(_ctx.inst_53c95);
   Svf_process_type_init(_ctx.inst_6a295);
   Adsr_do_type_init(_ctx.inst_7a095);
   _ctx.level1 = 0.0f;
   _ctx.level2 = 0.0f;
   _ctx.level3 = 0.0f;
   _ctx.level4 = 0.0f;
   _ctx.lfo_cv = 0.0f;
   _ctx.lfo_flt = 0.0f;
   _ctx.lfo_pw = 0.0f;
   _ctx.lfo_rate = 0.0f;
   _ctx.lfo_reset = 0.0f;
   _ctx.lfo_shape = 0.0f;
   _ctx.pw1 = 0.0f;
   _ctx.pw2 = 0.0f;
   _ctx.pw3 = 0.0f;
   _ctx.pw4 = 0.0f;
   _ctx.release = 0.0f;
   _ctx.sustain = 0.0f;
}

float Tricore_process(Tricore_process_type& _ctx, float cv, float reset, float disable) {
   float out = 0.0f;
   if (Util_change(_ctx.inst_1b03c, cv)) {
      _ctx.rate = (4.0f * Util_cvToRate_1024(cv));
   }
   float new_phase = 0.0f;
   float _if_temp_0 = 0.0f;
   if (_ctx.direction) {
      _if_temp_0 = _ctx.rate;
   }
   else {
      _if_temp_0 = (- _ctx.rate);
   }
   new_phase = (_if_temp_0 + _ctx.phase);
   bool bdisable = (disable > 0.5f);
   if (Util_edge(_ctx.inst_2043c, (reset > 0.0f)) || Util_edge(_ctx.inst_3043c, bdisable)) {
      _ctx.reset_phase = _ctx.phase;
      _ctx.reset_state = true;
      new_phase = 0.0f;
   }
   if (new_phase > 1024.0f) {
      new_phase = (2048.0f + (- new_phase));
      _ctx.direction = false;
   }
   else {
      if (new_phase < -1024.0f) {
         _ctx.direction = true;
         new_phase = (0.0f + new_phase);
      }
   }
   if (bdisable) {
      _ctx.phase = 0.0f;
   }
   else {
      _ctx.phase = new_phase;
   }
   if (_ctx.reset_state) {
      if ((fabsf(_ctx.reset_phase) > 10.0f) || bdisable) {
         float reset_speed = 0.0f;
         if (bdisable) {
            reset_speed = 0.01f;
         }
         else {
            reset_speed = 0.5f;
         }
         _ctx.reset_phase = ((- (reset_speed * _ctx.reset_phase)) + _ctx.reset_phase);
      }
      else {
         if (_ctx.reset_phase > 10.0f) {
            _ctx.reset_phase = _ctx.reset_phase;
         }
         else {
            _ctx.reset_phase = 0.0f;
         }
         _ctx.reset_state = false;
         _ctx.direction = true;
      }
      out = _ctx.reset_phase;
   }
   out = (out + _ctx.phase);
   return (0.0009766f * out);
}

float Svf_process(Svf_process_type& _ctx, float x, float cv, float q, int32_t sel) {
   q = (0.5f + q);
   if (Util_change(_ctx.inst_1b0a2, cv) || Util_change(_ctx.inst_2b0a2, q)) {
      _ctx.g = Svf_calc_g(cv);
      _ctx.r = (1.0f / (2.0f * (q + float_eps())));
      _ctx.inv_den = (1.0f / (1.0f + ((2.0f * (_ctx.r * _ctx.g)) + (_ctx.g * _ctx.g))));
   }
   float high = ((x + ((- (((2.0f * _ctx.r) + _ctx.g) * _ctx.z1)) + (- _ctx.z2))) * _ctx.inv_den);
   float band = ((high * _ctx.g) + _ctx.z1);
   float low = ((band * _ctx.g) + _ctx.z2);
   float notch = (high + low);
   _ctx.z1 = (band + (high * _ctx.g));
   _ctx.z2 = (low + (band * _ctx.g));
   float output = 0.0f;
   if (sel == 0) {
      output = low;
   }
   else {
      if (sel == 1) {
         output = high;
      }
      else {
         if (sel == 2) {
            output = band;
         }
         else {
            output = notch;
         }
      }
   }
   return Saturate_soft_process(output);
}

float Lfo_process(Lfo_process_type& _ctx, float cv, float shape, float reset) {
   if (Util_change(_ctx.inst_1b0d6, cv)) {
      _ctx.rate = Util_cvToRate((-0.3f + cv));
   }
   _ctx.phase = (_ctx.phase + _ctx.rate);
   if (_ctx.phase > 2.0f) {
      _ctx.phase = (-2.0f + _ctx.phase);
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   bool breset = (reset > 0.0f);
   if (Util_edge(_ctx.inst_204d6, breset)) {
      _ctx.phase = 0.0f;
   }
   float tmp = (-1.0f + _ctx.phase);
   float o = 0.0f;
   if (shape < 1.0f) {
      o = tmp;
   }
   else {
      if (shape < 2.0f) {
         o = (-1.0f + (2.0f * fabsf(tmp)));
      }
      else {
         if (tmp > 0.0f) {
            o = 1.0f;
         }
         else {
            o = 0.0f;
         }
      }
   }
   return Lfo_soft(_ctx.inst_337d6, o);
}

float Phase_process(Phase_process_type& _ctx, float cv, float reset) {
   if (Util_change(_ctx.inst_1b08a, cv)) {
      _ctx.rate = Util_cvToRate_1024(cv);
   }
   if (Util_edge(_ctx.inst_2048a, (reset > 0.5f))) {
      _ctx.phase = 0.0f;
   }
   else {
      _ctx.phase = (_ctx.phase + _ctx.rate);
   }
   if (_ctx.phase > 1024.0f) {
      _ctx.phase = (-1024.0f + _ctx.phase);
   }
   else {
      _ctx.phase = _ctx.phase;
   }
   return (0.0009766f * _ctx.phase);
}

float Blit_pulse_train(Blit_pulse_train_type& _ctx, float cv, float phase) {
   if (Util_change(_ctx.inst_1b05e, cv)) {
      _ctx.m = (1 + (2 * float_to_int(Util_cvToperiod(cv))));
      _ctx.scale = (2.0f * Util_cvToperiod(cv));
   }
   float pi_phase = (0.5f * phase);
   float denominator = Tables_nsine(pi_phase);
   float out = 0.0f;
   if (denominator <= float_eps()) {
      out = 1.0f;
   }
   else {
      float m_phase = fmodf((pi_phase * int_to_float(_ctx.m)), 1.0f);
      float numerator = Tables_nsine(m_phase);
      out = (numerator / (denominator * _ctx.scale));
   }
   return out;
}

float Blit_osc_blit(Blit_osc_blit_type& _ctx, float cv, float pw, float wave) {
   float fixed_cv = 0.0f;
   if (wave < 1.0f) {
      fixed_cv = cv;
   }
   else {
      fixed_cv = (-0.1f + cv);
   }
   if (Util_change(_ctx.inst_1b026, fixed_cv)) {
      _ctx.rate = Util_cvToRate(fixed_cv);
   }
   float phase = Phase_process(_ctx.inst_28a26, fixed_cv, 0.0f);
   float shift05 = (0.5f + (0.49f * pw));
   float shift = (phase + shift05);
   if (shift > 1.0f) {
      shift = (-1.0f + shift);
   }
   float pulse1 = Blit_pulse_train(_ctx.inst_35e26, fixed_cv, phase);
   float pulse2 = Blit_pulse_train(_ctx.inst_45e26, fixed_cv, shift);
   _ctx.state_pulse = (pulse1 + ((- pulse2) + (0.9995f * _ctx.state_pulse)));
   _ctx.state_saw = ((0.5f * ((pulse1 + (pulse2 + (-2.0f * _ctx.rate))) / shift05)) + (0.9995f * _ctx.state_saw));
   if (wave < 1.0f) {
      _ctx.output = _ctx.state_pulse;
   }
   else {
      _ctx.output = (2.0f * _ctx.state_saw);
   }
   _ctx.output = Util_dcblock(_ctx.inst_56426, _ctx.output);
   return _ctx.output;
}

float Adsr_do(Adsr_do_type& _ctx, float gate, float a, float d, float s, float r) {
   float a_rate = (1.0f / (0.01f + (100.0f * a)));
   float d_rate = (1.0f / (0.01f + (100.0f * d)));
   float r_rate = (1.0f / (0.01f + (100.0f * r)));
   _ctx.out = ((0.004f * (((- _ctx.out) + _ctx.target) * _ctx.rate)) + _ctx.out);
   bool bgate = (gate > 0.0f);
   if (_ctx.state == 0) {
      if (Util_edge(_ctx.inst_104a0, bgate)) {
         _ctx.state = 1;
         _ctx.scale = (0.2f * gate);
      }
      _ctx.rate = r_rate;
      _ctx.target = 0.0f;
   }
   if (_ctx.state == 1) {
      if (bgate == false) {
         _ctx.state = 0;
      }
      if (_ctx.out > 1024.0f) {
         _ctx.state = 2;
      }
      _ctx.rate = a_rate;
      _ctx.target = 1228.8f;
   }
   if (_ctx.state == 2) {
      if (bgate == false) {
         _ctx.state = 0;
      }
      _ctx.rate = d_rate;
      _ctx.target = (1024.0f * s);
   }
   return (Util_smooth(_ctx.inst_295a0, _ctx.scale) * float_clip((0.0009766f * _ctx.out), 0.0f, 1.0f));
}

void Adsr_controlChange(Adsr_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 1) {
      _ctx.knob1 = (0.0078741f * int_to_float(value));
   }
   if (control == 2) {
      _ctx.knob2 = (0.0078741f * int_to_float(value));
   }
   if (control == 3) {
      _ctx.knob3 = (0.0078741f * int_to_float(value));
   }
   if (control == 4) {
      _ctx.knob4 = (0.0078741f * int_to_float(value));
   }
}

void Voice_4_controlChange(Voice_4_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
   if (control == 30) {
      _ctx.level1 = (0.0078741f * int_to_float(value));
   }
   if (control == 31) {
      _ctx.level2 = (0.0078741f * int_to_float(value));
   }
   if (control == 32) {
      _ctx.level3 = (0.0078741f * int_to_float(value));
   }
   if (control == 33) {
      _ctx.level4 = (0.0078741f * int_to_float(value));
   }
   if (control == 34) {
      _ctx.pw1 = (0.0078741f * int_to_float(value));
   }
   if (control == 35) {
      _ctx.pw2 = (0.0078741f * int_to_float(value));
   }
   if (control == 36) {
      _ctx.pw3 = (0.0007875f * int_to_float(value));
   }
   if (control == 37) {
      _ctx.pw4 = (0.0078741f * int_to_float(value));
   }
   if (control == 38) {
      _ctx.lfo_rate = Util_map(int_to_float(value), 0.0f, 127.0f, -0.4f, 0.1f);
   }
   if (control == 39) {
      _ctx.lfo_shape = (0.0236221f * int_to_float(value));
   }
   if (control == 40) {
      _ctx.lfo_pw = Util_map(int_to_float(value), 0.0f, 127.0f, -1.0f, 1.0f);
   }
   if (control == 41) {
      _ctx.lfo_cv = Util_map(int_to_float(value), 0.0f, 127.0f, -0.1f, 0.1f);
   }
   if (control == 42) {
      _ctx.lfo_flt = Util_map(int_to_float(value), 0.0f, 127.0f, -0.3f, 0.3f);
   }
   if (control == 43) {
      if (value > 0) {
         _ctx.lfo_reset = 1.0f;
      }
      else {
         _ctx.lfo_reset = 0.0f;
      }
   }
   if (control == 44) {
      _ctx.flt_cut = Util_map(int_to_float(value), 0.0f, 127.0f, -0.2f, 0.5f);
   }
   if (control == 45) {
      _ctx.flt_res = (0.0078741f * int_to_float(value));
   }
   if (control == 46) {
      _ctx.flt_shape = ((4 * value) / 127);
   }
   if (control == 47) {
      _ctx.attack = (0.0078741f * int_to_float(value));
   }
   if (control == 48) {
      _ctx.decay = (0.0078741f * int_to_float(value));
   }
   if (control == 49) {
      _ctx.sustain = (0.0078741f * int_to_float(value));
   }
   if (control == 50) {
      _ctx.release = (0.0078741f * int_to_float(value));
   }
}

