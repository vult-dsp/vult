/* This code was generated by the Vult compiler v1-dev https://github.com/vult-dsp/vult */
#ifndef LADDER_H
#define LADDER_H

#include "vultin.h"
#include "ladder.tables.h"

typedef struct Util_edge_type {
   bool pre;
} Util_edge_type;

typedef struct Util_change_type {
   fix16_t pre_x;
} Util_change_type;

typedef struct Util_dcblock_type {
   fix16_t x1;
   fix16_t y1;
} Util_dcblock_type;

typedef struct Util_smooth_type {
   fix16_t x;
} Util_smooth_type;

typedef struct Util_average2_type {
   fix16_t x0;
} Util_average2_type;

typedef struct Ladder_heun_type {
   fix16_t p0;
   fix16_t p1;
   fix16_t p2;
   fix16_t p3;
} Ladder_heun_type;

typedef struct Ladder_euler_type {
   fix16_t p0;
   fix16_t p1;
   fix16_t p2;
   fix16_t p3;
} Ladder_euler_type;

typedef struct Ladder_process_euler_type {
   Ladder_euler_type e;
   fix16_t fh;
   Util_change_type inst_1b099;
} Ladder_process_euler_type;

typedef struct Ladder_process_heun_type {
   fix16_t fh;
   Ladder_heun_type h;
   Util_change_type inst_1b0a0;
} Ladder_process_heun_type;

typedef struct Ladder_process_type {
   Ladder_process_heun_type inst_1a0c3;
} Ladder_process_type;

typedef struct Ladder_process_type Ladder_noteOn_type;

typedef struct Ladder_process_type Ladder_noteOff_type;

typedef struct Ladder_process_type Ladder_controlChange_type;

typedef struct Ladder_process_type Ladder_default_type;

static_inline void Util_edge_type_init(Util_edge_type& _ctx) {
   _ctx.pre = false;
}

static_inline void Util_change_type_init(Util_change_type& _ctx) {
   _ctx.pre_x = 0x0 /* 0.000000 */;
}

static_inline void Util_dcblock_type_init(Util_dcblock_type& _ctx) {
   _ctx.x1 = 0x0 /* 0.000000 */;
   _ctx.y1 = 0x0 /* 0.000000 */;
}

static_inline void Util_smooth_type_init(Util_smooth_type& _ctx) {
   _ctx.x = 0x0 /* 0.000000 */;
}

static_inline void Util_average2_type_init(Util_average2_type& _ctx) {
   _ctx.x0 = 0x0 /* 0.000000 */;
}

static_inline void Ladder_heun_type_init(Ladder_heun_type& _ctx) {
   _ctx.p0 = 0x0 /* 0.000000 */;
   _ctx.p1 = 0x0 /* 0.000000 */;
   _ctx.p2 = 0x0 /* 0.000000 */;
   _ctx.p3 = 0x0 /* 0.000000 */;
}

static_inline void Ladder_euler_type_init(Ladder_euler_type& _ctx) {
   _ctx.p0 = 0x0 /* 0.000000 */;
   _ctx.p1 = 0x0 /* 0.000000 */;
   _ctx.p2 = 0x0 /* 0.000000 */;
   _ctx.p3 = 0x0 /* 0.000000 */;
}

static_inline void Ladder_process_euler_type_init(Ladder_process_euler_type& _ctx) {
   Ladder_euler_type_init(_ctx.e);
   _ctx.fh = 0x0 /* 0.000000 */;
   Util_change_type_init(_ctx.inst_1b099);
}

static_inline void Ladder_process_heun_type_init(Ladder_process_heun_type& _ctx) {
   _ctx.fh = 0x0 /* 0.000000 */;
   Ladder_heun_type_init(_ctx.h);
   Util_change_type_init(_ctx.inst_1b0a0);
}

static_inline void Ladder_process_type_init(Ladder_process_type& _ctx) {
   Ladder_process_heun_type_init(_ctx.inst_1a0c3);
}

static_inline void Ladder_noteOn_type_init(Ladder_noteOn_type& _ctx) {
   Ladder_process_type_init(_ctx);
}

static_inline void Ladder_noteOff_type_init(Ladder_noteOff_type& _ctx) {
   Ladder_process_type_init(_ctx);
}

static_inline void Ladder_controlChange_type_init(Ladder_controlChange_type& _ctx) {
   Ladder_process_type_init(_ctx);
}

static_inline void Ladder_default_type_init(Ladder_default_type& _ctx) {
   Ladder_process_type_init(_ctx);
}

static_inline bool Util_edge(Util_edge_type& _ctx, bool x) {
   bool ret = x && (_ctx.pre == false);
   _ctx.pre = x;
   return ret;
}

static_inline bool Util_change(Util_change_type& _ctx, fix16_t x) {
   bool v = _ctx.pre_x != x;
   _ctx.pre_x = x;
   return v;
}

static_inline fix16_t Util_map(fix16_t x, fix16_t x0, fix16_t x1, fix16_t y0, fix16_t y1) {
   return y0 + fix_div(fix_mul(x + (- x0), y1 + (- y0)), x1 + (- x0));
}

static_inline fix16_t Util_dcblock(Util_dcblock_type& _ctx, fix16_t x0) {
   fix16_t y0 = x0 + (- _ctx.x1) + fix_mul(0xfeb8 /* 0.995000 */, _ctx.y1);
   _ctx.x1 = x0;
   _ctx.y1 = y0;
   return y0;
}

static_inline fix16_t Util_smooth(Util_smooth_type& _ctx, fix16_t input) {
   _ctx.x = fix_mul(0x147 /* 0.005000 */, input + (- _ctx.x)) + _ctx.x;
   return _ctx.x;
}

static_inline fix16_t Util_average2(Util_average2_type& _ctx, fix16_t x1) {
   fix16_t result = fix_mul(0x8000 /* 0.500000 */, x1 + _ctx.x0);
   _ctx.x0 = x1;
   return result;
}

static_inline fix16_t Util_cubic_clipper(fix16_t x) {
   if (x <= -0xaaaa /* -0.666667 */) {
      return -0xaaaa /* -0.666667 */;
   }
   else {
      if (x >= 0xaaaa /* 0.666667 */) {
         return 0xaaaa /* 0.666667 */;
      }
      else {
         return x + fix_mul(-0x5555 /* -0.333333 */, fix_mul(x, fix_mul(x, x)));
      }
   }
}

static_inline fix16_t Util_pitchToRate_1024_raw_c0(int32_t index) {
   return Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_pitchToRate_1024_raw_c1(int32_t index) {
   return Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_pitchToRate_1024(fix16_t pitch) {
   fix16_t value = fix_clip(fix_mul(pitch, 0x3e7c /* 0.244094 */), 0x0 /* 0.000000 */, 0x1f0000 /* 31.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_pitchToRate_1024_c0[static_cast<uint32_t>(index)] + fix_mul(Util_pitchToRate_1024_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Util_pitchToRate_raw_c0(int32_t index) {
   return Util_pitchToRate_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_pitchToRate_raw_c1(int32_t index) {
   return Util_pitchToRate_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_pitchToRate(fix16_t pitch) {
   fix16_t value = fix_clip(fix_mul(pitch, 0x3e7c /* 0.244094 */), 0x0 /* 0.000000 */, 0x1f0000 /* 31.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_pitchToRate_c0[static_cast<uint32_t>(index)] + fix_mul(Util_pitchToRate_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Util_cvToPitch(fix16_t cv) {
   return 0x180000 /* 24.000000 */ + fix_mul(0x780000 /* 120.000000 */, cv);
}

static_inline fix16_t Util_cvToRate_1024_raw_c0(int32_t index) {
   return Util_cvToRate_1024_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToRate_1024_raw_c1(int32_t index) {
   return Util_cvToRate_1024_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToRate_1024(fix16_t cv) {
   fix16_t value = fix_clip(fix_mul(cv, 0x2271c7 /* 34.444444 */), 0x0 /* 0.000000 */, 0x1f0000 /* 31.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_cvToRate_1024_c0[static_cast<uint32_t>(index)] + fix_mul(Util_cvToRate_1024_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Util_cvToRate_raw_c0(int32_t index) {
   return Util_cvToRate_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToRate_raw_c1(int32_t index) {
   return Util_cvToRate_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToRate(fix16_t cv) {
   fix16_t value = fix_clip(fix_mul(cv, 0x8d1c71 /* 141.111111 */), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_cvToRate_c0[static_cast<uint32_t>(index)] + fix_mul(Util_cvToRate_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Util_pitchToCv(fix16_t pitch) {
   return -0x3333 /* -0.200000 */ + fix_mul(0x222 /* 0.008333 */, pitch);
}

static_inline fix16_t Util_cvToperiod_raw_c0(int32_t index) {
   return Util_cvToperiod_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToperiod_raw_c1(int32_t index) {
   return Util_cvToperiod_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvToperiod(fix16_t cv) {
   fix16_t value = fix_clip(fix_mul(cv, 0x1f0000 /* 31.000000 */), 0x0 /* 0.000000 */, 0x1f0000 /* 31.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_cvToperiod_c0[static_cast<uint32_t>(index)] + fix_mul(Util_cvToperiod_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Util_cvTokHz_raw_c0(int32_t index) {
   return Util_cvTokHz_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvTokHz_raw_c1(int32_t index) {
   return Util_cvTokHz_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Util_cvTokHz(fix16_t cv) {
   fix16_t value = fix_clip(fix_mul(cv, 0x1f0000 /* 31.000000 */), 0x0 /* 0.000000 */, 0x1f0000 /* 31.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Util_cvTokHz_c0[static_cast<uint32_t>(index)] + fix_mul(Util_cvTokHz_c1[static_cast<uint32_t>(index)], decimal);
}

static_inline fix16_t Ladder_tune_raw_c0(int32_t index) {
   return Ladder_tune_c0[static_cast<uint32_t>(index)];
}

static_inline fix16_t Ladder_tune_raw_c1(int32_t index) {
   return Ladder_tune_c1[static_cast<uint32_t>(index)];
}

static_inline fix16_t Ladder_tune(fix16_t cut) {
   fix16_t value = fix_clip(fix_mul(cut, 0x7f0000 /* 127.000000 */), 0x0 /* 0.000000 */, 0x7f0000 /* 127.000000 */);
   int32_t index = fix_to_int(value);
   fix16_t decimal = value - fix_floor(value);
   return Ladder_tune_c0[static_cast<uint32_t>(index)] + fix_mul(Ladder_tune_c1[static_cast<uint32_t>(index)], decimal);
}

fix16_t Ladder_heun(Ladder_heun_type& _ctx, fix16_t input, fix16_t fh, fix16_t res);

fix16_t Ladder_euler(Ladder_euler_type& _ctx, fix16_t input, fix16_t fh, fix16_t res);

fix16_t Ladder_process_euler(Ladder_process_euler_type& _ctx, fix16_t input, fix16_t cut, fix16_t res);

fix16_t Ladder_process_heun(Ladder_process_heun_type& _ctx, fix16_t input, fix16_t cut, fix16_t res);

static_inline fix16_t Ladder_process(Ladder_process_type& _ctx, fix16_t input, fix16_t cut, fix16_t res) {
   return Ladder_process_heun(_ctx.inst_1a0c3, input, cut, res);
}

static_inline void Ladder_noteOn(Ladder_process_type& _ctx, int32_t note, int32_t velocity, int32_t channel) {
}

static_inline void Ladder_noteOff(Ladder_process_type& _ctx, int32_t note, int32_t channel) {
}

static_inline void Ladder_controlChange(Ladder_process_type& _ctx, int32_t control, int32_t value, int32_t channel) {
}

static_inline void Ladder_default(Ladder_process_type& _ctx) {
}


#endif // LADDER_H
