<link rel="stylesheet" type="text/css" href="../../css/vult.css" media="screen">

<div class="header">
	<center><img src="../../images/VultH.png" alt="Vult" title="Vult" align="middle"></center>
</div>

<link href="https://fonts.googleapis.com/css?family=Francois+One|Rasa" rel="stylesheet">
<script src="https://use.fontawesome.com/aa67c38f9b.js"></script>
<div class="menu" align="middle">
  <ul>
    <li><a href="../../"><i class='fa fa-home'></i> Home</a></li>
    <li><a href="../../overview"><i class='fa fa-bullseye'></i> Overview</a></li>
    <li><a href="../../tutorials"><i class='fa fa-book'></i> Tutorials</a></li>
    <li><a href="../../blog"><i class='fa fa-newspaper-o'></i> Blog</a></li>
    <li><a href="../../demo"><i class='fa fa-code'></i>Live Demo</a></li>
    <li><a href="https://github.com/modlfo/vult"><i class='fa fa-code-fork'></i>Source</a></li>
  </ul>
</div>

<div class="content">
    <h2>Generating C/C&#43;&#43;</h2>
  

<p>Once we have some Vult code written it&rsquo;s time to generate some C/C++ code and run it on a target.</p>

<p>If you have followed the installation steps show in <a href="https://github.com/modlfo/vult">https://github.com/modlfo/vult</a> you will have an executable called <code>vultc</code> (most probably <code>vultc.native</code> or <code>vultc.byte</code>). This is a simple command line application that we will use to generate the code.</p>

<p>Here is the full code of the oversampled lowpass filter which we are gonna save in a file called <code>filter.vult</code>.</p>

<div class="vult_code" id="tut5-1">
// returns true when the input changes
fun change(current:real) : bool {
   mem previous;
   val result = current <> previous;
   previous = current;
   return result;
}

fun biquad(x0, b0, b1, b2 ,a1 ,a2) : real {
    mem w1, w2;
    val w0 = x0 - a1*w1 - a2*w2;
    val y0 = b0*w0 + b1*w1 + b2*w2;
    w2, w1 = w1, w0;
    return y0;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 = (-2.0*cos_w)/den;
        a2 = (1.0-alpha)/den;
        b0 = (1.0-cos_w)/(2.0*den);
        b1 = (1.0-cos_w)/den;
        b2 = (1.0-cos_w)/(2.0*den);
    }
    return biquad(x,b0,b1,b2,a1,a2);
}

fun lowpass_2x(x,w0,q) {
    val fixed_w0 = w0/2.0;
    // first call to lowpass with context 'inst'
    _  = inst:lowpass(x,fixed_w0,q);
    // second call to lowpass with the same context 'inst'
    val y = inst:lowpass(x,fixed_w0,q);
    return y;
}
</div>

<p>Next we are gonna call the Vult compiler as follows:</p>

<pre><code>$ ./vultc.native -ccode filter.vult
</code></pre>

<p>The compiler receives the flag <code>-ccode</code> which instruct the compiler to generate C/C++ code. This command will print to the standard output the generated code. If we want to save it to a file we have to call the compiler as follows:</p>

<pre><code>$ ./vultc.native -ccode filter.vult -o filter
</code></pre>

<p>This will generate two files: <code>filter.h</code> and <code>filter.cpp</code>. Vult generates many auxiliary functions and types. For each function with memory (for example a function called <code>foo</code> in the file <code>Bar.vult</code>) there&rsquo;s gonna be:</p>

<ul>
<li>a type with the name <code>Bar_foo_type</code></li>
<li>a initialization function with the name <code>Bar_foo_init</code></li>
<li>a function with the body of the original Vult function called <code>Bar_foo</code></li>
</ul>

<p>In the case of the filter example the names are: <code>Filter_lowpass_2x_type</code>, <code>Filter_lowpass_2x_init</code> and <code>Filter_lowpass_2x</code>.</p>

<p>To use this code in a file you need to:</p>

<ul>
<li>create a value of type <code>Filter_lowpass_2x_type</code></li>
<li>initialize it with the function <code>Filter_lowpass_2x_init</code></li>
<li>use it with the original function <code>Filter_lowpass_2x</code></li>
</ul>

<p>For example:</p>

<div class="c_code" id="tut5-2">// file main.cpp

#include "filter.h"

int main(void) {
   Filter_lowpass_2x_type filter;
   // initialization
   Filter_lowpass_2x_init(filter);

   // inputs to the function
   float x = 0.0f;
   float w = 1.0f;
   float q = 1.0f;

   // calling the function
   float result = Filter_lowpass_2x(filter,x,w,q);

   return 0;
}
</div>

<p>In order to compile this code you need to add an include directory pointing to the location of the file <code>vultin.h</code>. This file is located in the source tree under the folder <code>runtime</code>. To link you will need to compile and link the file <code>vultin.c</code> which is located in the same place (<a href="https://github.com/modlfo/vult/tree/master/runtime">https://github.com/modlfo/vult/tree/master/runtime</a>)</p>

<p>One thing to notice is that every function with memory will have as first argument a reference to a value of it&rsquo;s corresponding type. In the above case, the function <code>Filter_lowpass_2x</code> returns only one value, therefore the C/C++ will return a value. If the functions return more than one value Vult will automatically generate structures for the types. Here are few Vult functions an their corresponding C/C++ functions:</p>

<div class="vult_code" id="tut5-3">// example.vult
// single value return, no memory
fun foo1(x:real) {
    return x;
}

// single value return, with memory
fun bar1(x:real) {
    mem y = x;
    return x;
}

// multiple value return, no memory
fun foo2(x:real) {
    return x,x;
}

// multiple value return, with memory
fun bar2(x:real) {
    mem y = x;
    return x,x;
}
</div>

<p>C/C++ declarations of the functions above:</p>

<div class="c_code" id="tut5-4">
// single value return, no memory
float Example_foo1(float x);

// single value return, with memory
float Example_bar1(Example__ctx_type_1 &_ctx, float x);

// multiple value return, no memory
void Example_foo2(float x, _tuple_real_real &_output_);

// multiple value return, with memory
void Example_bar2(Example__ctx_type_3 &_ctx, float x,
   _tuple_real_real &_output_);
</div>

<p>In the examples above you can see that Vult adds an extra argument at the end that is used to return multiple values.</p>

<h2 id="generating-fixed-point-code">Generating fixed-point code</h2>

<p>When generating C/C++ code Vult by default uses floating point arithmetic (<code>float</code> numbers). Floating point code is very efficient in big processors like the x86. However when compiled to small microcontrollers (like the ones found in Arduinos or some ARM processors) the code can be very inefficient because these processors do not have a dedicated floating point arithmetic unit.</p>

<p>Alternatively, fixed-point calculations can be used to perform computations with decimals (like <code>2.0*1.5</code>). Fixed-point arithmetic encodes the decimal numbers as integers and uses the integer arithmetic unit in small processors to perform calculations (<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">https://en.wikipedia.org/wiki/Fixed-point_arithmetic</a>). The result is that the operations can be performed efficiently at the expense of numeric precision.</p>

<p>Vult can generate all operations with real numbers as fixed-point with the format q16.16. This means that 16 bits a used to represent integers and 16 bits for decimals. This implies that the largest number that can be represented is <code>32767.0</code> and the smallest <code>0.0000152588</code> (the values are signed). Therefore, when generating code with fixed-point numbers one needs to be careful of not going beyond this numbers.</p>

<p>To generate code with fixed-point numbers we need to call Vult as follows:</p>

<pre><code>$ ./vultc.native -ccode -real fixed filter.vult -o filter
</code></pre>

<p>This command will generate use the type <code>fix16_t</code> instead of <code>float</code>. For example, the declaration of the function <code>lowpass_2x</code> changes to:</p>

<div class="c_code" id="tut5-5">
fix16_t Filter_lowpass_2x(Filter__ctx_type_3 &_ctx, fix16_t x,
                          fix16_t w0, fix16_t q);
</div>

<p>The file <code>vultin.h</code> provides functions to convert among <code>float</code> <code>fix16_t</code> and <code>int</code> values.</p>

<script type="text/javascript" src="../../javascripts/external/ace/ace.js"></script>
<script type="text/javascript" src="../../javascripts/main.js"></script>

</div>

<script src="https://apis.google.com/js/plusone.js"></script>

<center><div id="comments"></div></center>
<script>
gapi.comments.render('comments', {
    href: window.location,
    width: '624',
    first_party_property: 'BLOGGER',
    view_type: 'FILTERED_POSTMOD'
});
</script>

