<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Vult by modlfo</title>
    <link>http://modlfo.github.io/vult/tutorials/</link>
    <description>Recent content in Tutorials on Vult by modlfo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Dec 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://modlfo.github.io/vult/tutorials/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Vult Language Basics</title>
      <link>http://modlfo.github.io/vult/tutorials/basics/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/basics/</guid>
      <description>&lt;p&gt;Vult has syntax that may resemble languages like C/C++, Python or JavaScript. In order to declare a function you can use the keyword &lt;code&gt;fun&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-0&#34;&gt;fun foo() return 0;
&lt;/div&gt;

&lt;p&gt;This functions takes no arguments and returns the integer value zero. If you have more than one statement you can use the curly braces &lt;code&gt;{}&lt;/code&gt; to delimit the function body.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-1&#34;&gt;fun foo(x) {
   val y = 1 + x;
   return y;
}
&lt;/div&gt;

&lt;p&gt;As you may have seen, you can declare variables with the keyword &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vult is a static language, this means that every variable has concrete type. Since Vult is focused on numeric computations there are two main types available: &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;. You can specify the type of the variables with colon &lt;code&gt;:&lt;/code&gt; as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-2&#34;&gt;fun foo(x : int) : int {
   val y : int = 1 + x;
   return y;
}
&lt;/div&gt;

&lt;p&gt;This specifies that the function receives an argument &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; and returns a value of type &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The type annotations are not strictly necessary. Vult has type inference which means that it will try to automatically determine every type based on the use of the variables. We will cover more about the type inference in a different tutorial.&lt;/p&gt;

&lt;p&gt;Function in Vult can return multiple values separated by commas. The values can be assigned to multiple variables in a similar way.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-3&#34;&gt;fun foo() {
   return 1, 2;
}

fun bar(){
   val a, b = foo();
}
&lt;/div&gt;

&lt;p&gt;As mentioned before, Vult is static and strict. It is not possible to mix operations between reals and integers without making an explicit cast. The following operation is invalid:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-4&#34;&gt;fun foo() {
   val x = 1;
   val y = 2.1;
   return x + y; // invalid operation
}
&lt;/div&gt;

&lt;p&gt;The problem here is that the values have different type. The number &lt;code&gt;1&lt;/code&gt; is of type &lt;code&gt;int&lt;/code&gt; and the number &lt;code&gt;2.1&lt;/code&gt; is of type &lt;code&gt;real&lt;/code&gt;. In order to perform operations, you need to explicitly cast the values. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut1-5&#34;&gt;fun foo() {
   val x = 1;
   val y = 2.1;
   val z = x + int(y);  // z = 3
   val w = real(x) + y; // w = 3.1
   return w;
}
&lt;/div&gt;

&lt;p&gt;By not making automatic conversion of types Vult gives you a more control on the kind of operation you want to perform.&lt;/p&gt;

&lt;p&gt;In the following tutorials we will cover more advanced aspects of Vult.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Functions with Memory</title>
      <link>http://modlfo.github.io/vult/tutorials/functions/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/functions/</guid>
      <description>&lt;p&gt;Vult has two types of functions: passive and active. Passive functions are like the examples that we saw in the Vult Language Basics, for example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-0&#34;&gt;fun square(x) {
   return x * x;
}
&lt;/div&gt;

&lt;p&gt;These functions simply receive arguments, perform computations and return a value.&lt;/p&gt;

&lt;p&gt;One of the most useful features of Vult are the active functions. These functions have the characteristic that have internal and independent memory variables. The memory variables are declared with the keyword &lt;code&gt;mem&lt;/code&gt;. For example, if we would like to make a counter in Vult we could write the following function:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-1&#34;&gt;fun counter(n) {
   mem count;         // our memory variable
   count = count + n; // increases the value by &#39;n&#39; and updates it
   return count;      // returns the new count
}

fun loop() {
   val x = counter(1); // every time count is called the value increases 1
}
&lt;/div&gt;

&lt;p&gt;In the code shown above, let&amp;rsquo;s assume that an external function calls repeatedly the function &lt;code&gt;loop&lt;/code&gt;. Every time the function &lt;code&gt;loop&lt;/code&gt; is called, the function &lt;code&gt;counter&lt;/code&gt; is called and increases the value of the memory variable &lt;code&gt;count&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;One very important thing to note is that every call to an active function creates a new context.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;For example, if we have the following code:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-3&#34;&gt;fun loop() {
   val first = counter(1);   // first counter, increases by 1
   val second = counter(10); // second counter, increases by 10
}
&lt;/div&gt;

&lt;p&gt;the first call to &lt;code&gt;counter&lt;/code&gt; creates it&amp;rsquo;s own &lt;code&gt;count&lt;/code&gt; variable and is not affected by the second call. So the values of &lt;code&gt;first&lt;/code&gt; will be &lt;code&gt;1, 2, 3 ...&lt;/code&gt; while the values of &lt;code&gt;second&lt;/code&gt; will be &lt;code&gt;10, 20, 30, ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Another example of using functions with memory is the following:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-4&#34;&gt;// Returns &#39;true&#39; every &#39;n&#39; calls
fun every(n) {
   // increments the variable and returns it to 0 when larger than n
   mem count = (count + 1) % n;
   // Return true if the variable is zero
   return (count == 0);
}
&lt;/div&gt;

&lt;p&gt;This function returns &lt;code&gt;true&lt;/code&gt; every &lt;code&gt;n&lt;/code&gt; times is called. This can be used to limit the number of times an expensive computation is performed. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-5&#34;&gt;
fun loop(){
   if(every(10)) {
      .... // perform an expensive computation
   }
}
&lt;/div&gt;

&lt;p&gt;Other function that can be very useful is:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut2-6&#34;&gt;// Returns &#39;true&#39; if the input value changes
fun change(current) {
   mem previous;
   val result = current &lt;&gt; previous;
   previous = current;
   return result;
}
&lt;/div&gt;

&lt;p&gt;In this case, the function returns &lt;code&gt;true&lt;/code&gt; every time it&amp;rsquo;s value changes compared to its previous value.&lt;/p&gt;

&lt;p&gt;In the following tutorial we will see more advanced use cases focusing on a DSP application.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Easy DSP with Vult</title>
      <link>http://modlfo.github.io/vult/tutorials/dsp/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/dsp/</guid>
      <description>&lt;p&gt;Functions with memory simplify writing Digital Signal Processing (DSP) code since a &lt;code&gt;mem&lt;/code&gt; variable can be used to as a single sample delay &lt;code&gt;z^1&lt;/code&gt;. I order to implement the Digital Biquad Filter (direct form 2) we can take the equations directly from Wikipedia: &lt;a href=&#34;https://en.wikipedia.org/wiki/Digital_biquad_filter&#34;&gt;https://en.wikipedia.org/wiki/Digital_biquad_filter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We can see the architecture and the equations here:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;../images/biquad-df2-eq1.svg&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/biquad-df2-eq2.svg&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;../images/biquad-df2-image.png&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;We can implement these equations in Vult as follows.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-1&#34;&gt;fun biquad(x0, b0, b1, b2 ,a1 ,a2) : real {
    mem w1, w2;
    val w0 = x0 - a1*w1 - a2*w2;
    val y0 = b0*w0 + b1*w1 + b2*w2;
    w2, w1 = w1, w0;
    return y0;
}
&lt;/div&gt;

&lt;p&gt;The variables &lt;code&gt;w1&lt;/code&gt; and &lt;code&gt;w2&lt;/code&gt; represent the terms &lt;code&gt;w[n-1]&lt;/code&gt; and &lt;code&gt;w[n-2]&lt;/code&gt;. The variables &lt;code&gt;y0&lt;/code&gt; and &lt;code&gt;x0&lt;/code&gt; represent &lt;code&gt;y[n]&lt;/code&gt; and &lt;code&gt;x[n]&lt;/code&gt;. The coefficients of the filter are &lt;code&gt;b0&lt;/code&gt;, &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; which are calculated depending on the filter. We can see that &lt;code&gt;w1&lt;/code&gt; and &lt;code&gt;w2&lt;/code&gt; are declared as &lt;code&gt;mem&lt;/code&gt; variables since we want them to keep their value every time the function is called.&lt;/p&gt;

&lt;p&gt;Now that we have the architecture of the biquad, we can design filters. In order to design a filter we need to calculate the coefficients. Here we are gonna follow the formulae show in the Audio-EQ-Cookbook (&lt;a href=&#34;http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt&#34;&gt;http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt&lt;/a&gt;). The code for the filter is the following:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-2&#34;&gt;fun lowpass(x,w0,q) {
    val cos_w = cos(w0);
    val alpha = sin(w0)/(2.0*q);
    val den =  1.0 + alpha;
    val a1 =  (-2.0*cos_w)/den;
    val a2 =  (1.0 - alpha)/den;
    val b0 = ((1.0 - cos_w)/(2.0*den));
    val b1 = (1.0 - cos_w)/den;
    val b2 = ((1.0 - cos_w)/(2.0*den));
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;In the code, &lt;code&gt;x&lt;/code&gt; is the input signal &lt;code&gt;w0&lt;/code&gt; is the cut frequency (in radians) and &lt;code&gt;q&lt;/code&gt; controls the resonance. This filter is variable and we can adjust the cut frequency and the resonance. In order to achieve that we need to calculate the coefficients every time the cut or resonance changes. We can see in the above code that the implementation is not very efficient since it calculates the coefficients every sample. To improve it can use the function &lt;code&gt;change&lt;/code&gt; that we defined in the &lt;code&gt;Functions with Memory&lt;/code&gt; tutorial.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-3&#34;&gt; // returns true when the input changes
fun change(current:real) : bool {
    mem previous;
    val result = current &lt;&gt; previous;
    previous = current;
    return result;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 =  (-2.0*cos_w)/den;
        a2 =  (1.0 - alpha)/den;
        b0 = ((1.0 - cos_w)/(2.0*den));
        b1 = (1.0 - cos_w)/den;
        b2 = ((1.0 - cos_w)/(2.0*den));
    }
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;In the example above, we have changed the declaration of the coefficients to &lt;code&gt;mem&lt;/code&gt; variables because we want to remember the previous values. By wrapping the calculation inside the &lt;code&gt;if-statement&lt;/code&gt; we recalculate the coefficients every time the values of &lt;code&gt;fc&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; change.&lt;/p&gt;

&lt;p&gt;Now that we have the filter, we can use it as part of a bigger program. For example:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut3-4&#34;&gt;
fun process(x) : real {

   ... // some other here

   val s_1 = ...; // generate a signal
   val s_2 = ...; // generate a signal

   // the first filter is controlled by control_1 and control_2
   val s_1_filtered = lowpass(s_1, control_1, control_2);

   // the second filter is controlled by control_3 and control_4
   val s_2_filtered = lowpass(s_2, control_3, control_4);

   return s_1_filtered + s_2_filtered;
}
&lt;/div&gt;

&lt;p&gt;Just for you to remember, every time you call the function &lt;code&gt;lowpass&lt;/code&gt; and independent memory space is generated. Therefore, the filter for signal &lt;code&gt;s_1&lt;/code&gt; and &lt;code&gt;s_2&lt;/code&gt; do not interfere each other.&lt;/p&gt;

&lt;p&gt;In the next tutorial we are gonna create a state-variable filter and we are gonna show how easy is to do oversampling in Vult.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Oversampling</title>
      <link>http://modlfo.github.io/vult/tutorials/oversampling/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/oversampling/</guid>
      <description>&lt;p&gt;One common technique in Digital Signal Processing is Oversampling. Oversampling is often necessary when modeling filters that come from electric circuits or that present nonlinearities or that can become unstable for certain parameters.&lt;/p&gt;

&lt;p&gt;In order to oversample a filter we need for every sample perform &lt;code&gt;N&lt;/code&gt; steps. I a language like Vult, that hides the internal memory of a function, oversampling may seem not very obvious.&lt;/p&gt;

&lt;p&gt;In order to perform oversampling, we are gonna use a feature of Vult that allow us to name and reuse the memory created by a function.&lt;/p&gt;

&lt;p&gt;In the previous tutorial &lt;code&gt;Easy DSP with Vult&lt;/code&gt; we coded the following low pass filter.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-1&#34;&gt; // returns true when the input changes
fun change(current:real) : bool {
   mem previous;
   val result = current &lt;&gt; previous;
   previous = current;
   return result;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 = (-2.0*cos_w)/den;
        a2 = (1.0-alpha)/den;
        b0 = (1.0-cos_w)/(2.0*den);
        b1 = (1.0-cos_w)/den;
        b2 = (1.0-cos_w)/(2.0*den);
    }
    return biquad(x,b0,b1,b2,a1,a2);
}
&lt;/div&gt;

&lt;p&gt;This filter becomes unstable when the parameter &lt;code&gt;q&lt;/code&gt; is high and the frequency &lt;code&gt;w0&lt;/code&gt; approaching &lt;code&gt;2Pi&lt;/code&gt; for that reason we cannot completely open the filter.&lt;/p&gt;

&lt;p&gt;The following code shows the low pass filter with 2x of oversampling:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-2&#34;&gt;fun lowpass_2x(x,w0,q) {
    val fixed_w0 = w0/2.0;
    // first call to lowpass with context &#39;inst&#39;
    _  = inst:lowpass(x,fixed_w0,q);
    // second call to lowpass with the same context &#39;inst&#39;
    val y = inst:lowpass(x,fixed_w0,q);
    return y;
}
&lt;/div&gt;

&lt;p&gt;First we need to fix the frequency &lt;code&gt;w0&lt;/code&gt;. From Audio-EQ-Cookbook we have the formula &lt;code&gt;w0 = 2*pi*f0/Fs&lt;/code&gt;, since we have double the sampling rate, it is enough to divide the original &lt;code&gt;w0&lt;/code&gt; by two. Then we use the feature of Vult that allow us to name the context of a function and reuse them. By preceding a call of a function with memory with an identifier and colon we can assign a name to the context e.g. &lt;code&gt;inst:lowpass(...)&lt;/code&gt;. If we want to call again the function and not creating a new context we have to use the same name.&lt;/p&gt;

&lt;p&gt;if we want to create modify the filter above and make it stereo we can do it as follows:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-3&#34;&gt;fun lowpass_2x(l,r,w0,q) {
    val fixed_w0 = w0/2.0;
    // process the left side
    _         = left:lowpass(l,fixed_w0,q);
    val l_out = left:lowpass(l,fixed_w0,q);
    // process the right side
    _         = right:lowpass(l,fixed_w0,q);
    val r_out = right:lowpass(r,fixed_w0,q);
    return l_out,r_out;
}
&lt;/div&gt;

&lt;p&gt;Notice that we have named the contexts of the functions &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;. In a similar way, we can easily make this filter with 4x of oversampling.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut4-4&#34;&gt;fun lowpass_4x(l,r,w0,q) {
    val fixed_w0 = w0/4.0;
    // process the left side
    _         = left:lowpass(l,fixed_w0,q);
    _         = left:lowpass(l,fixed_w0,q);
    _         = left:lowpass(l,fixed_w0,q);
    val l_out = left:lowpass(l,fixed_w0,q);
    // process the right side
    _         = right:lowpass(l,fixed_w0,q);
    _         = right:lowpass(l,fixed_w0,q);
    _         = right:lowpass(l,fixed_w0,q);
    val r_out = right:lowpass(r,fixed_w0,q);
    return l_out,r_out;
}
&lt;/div&gt;

&lt;p&gt;In the next tutorial we are gonna learn how to export code to C/C++.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>Generating C/C&#43;&#43;</title>
      <link>http://modlfo.github.io/vult/tutorials/generate-c/</link>
      <pubDate>Sun, 12 Jul 2015 21:24:58 +0200</pubDate>
      
      <guid>http://modlfo.github.io/vult/tutorials/generate-c/</guid>
      <description>

&lt;p&gt;Once we have some Vult code written it&amp;rsquo;s time to generate some C/C++ code and run it on a target.&lt;/p&gt;

&lt;p&gt;If you have followed the installation steps show in &lt;a href=&#34;https://github.com/modlfo/vult&#34;&gt;https://github.com/modlfo/vult&lt;/a&gt; you will have an executable called &lt;code&gt;vultc&lt;/code&gt; (most probably &lt;code&gt;vultc.native&lt;/code&gt; or &lt;code&gt;vultc.byte&lt;/code&gt;). This is a simple command line application that we will use to generate the code.&lt;/p&gt;

&lt;p&gt;Here is the full code of the oversampled lowpass filter which we are gonna save in a file called &lt;code&gt;filter.vult&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut5-1&#34;&gt;
// returns true when the input changes
fun change(current:real) : bool {
   mem previous;
   val result = current &lt;&gt; previous;
   previous = current;
   return result;
}

fun biquad(x0, b0, b1, b2 ,a1 ,a2) : real {
    mem w1, w2;
    val w0 = x0 - a1*w1 - a2*w2;
    val y0 = b0*w0 + b1*w1 + b2*w2;
    w2, w1 = w1, w0;
    return y0;
}

fun lowpass(x,w0,q) {
    mem b0,b1,b2,a1,a2;
    if(change(w0) || change(q)) {
        val cos_w = cos(w0);
        val alpha = sin(w0)/(2.0*q);
        val den =  1.0 + alpha;
        a1 = (-2.0*cos_w)/den;
        a2 = (1.0-alpha)/den;
        b0 = (1.0-cos_w)/(2.0*den);
        b1 = (1.0-cos_w)/den;
        b2 = (1.0-cos_w)/(2.0*den);
    }
    return biquad(x,b0,b1,b2,a1,a2);
}

fun lowpass_2x(x,w0,q) {
    val fixed_w0 = w0/2.0;
    // first call to lowpass with context &#39;inst&#39;
    _  = inst:lowpass(x,fixed_w0,q);
    // second call to lowpass with the same context &#39;inst&#39;
    val y = inst:lowpass(x,fixed_w0,q);
    return y;
}
&lt;/div&gt;

&lt;p&gt;Next we are gonna call the Vult compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -ccode filter.vult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler receives the flag &lt;code&gt;-ccode&lt;/code&gt; which instruct the compiler to generate C/C++ code. This command will print to the standard output the generated code. If we want to save it to a file we have to call the compiler as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -ccode filter.vult -o filter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate two files: &lt;code&gt;filter.h&lt;/code&gt; and &lt;code&gt;filter.cpp&lt;/code&gt;. Vult generates many auxiliary functions and types. For each function with memory (for example a function called &lt;code&gt;foo&lt;/code&gt; in the file &lt;code&gt;Bar.vult&lt;/code&gt;) there&amp;rsquo;s gonna be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a type with the name &lt;code&gt;Bar_foo_type&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a initialization function with the name &lt;code&gt;Bar_foo_init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a function with the body of the original Vult function called &lt;code&gt;Bar_foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the case of the filter example the names are: &lt;code&gt;Filter_lowpass_2x_type&lt;/code&gt;, &lt;code&gt;Filter_lowpass_2x_init&lt;/code&gt; and &lt;code&gt;Filter_lowpass_2x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To use this code in a file you need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a value of type &lt;code&gt;Filter_lowpass_2x_type&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;initialize it with the function &lt;code&gt;Filter_lowpass_2x_init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;use it with the original function &lt;code&gt;Filter_lowpass_2x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class=&#34;c_code&#34; id=&#34;tut5-2&#34;&gt;// file main.cpp

#include &#34;filter.h&#34;

int main(void) {
   Filter_lowpass_2x_type filter;
   // initialization
   Filter_lowpass_2x_init(filter);

   // inputs to the function
   float x = 0.0f;
   float w = 1.0f;
   float q = 1.0f;

   // calling the function
   float result = Filter_lowpass_2x(filter,x,w,q);

   return 0;
}
&lt;/div&gt;

&lt;p&gt;In order to compile this code you need to add an include directory pointing to the location of the file &lt;code&gt;vultin.h&lt;/code&gt;. This file is located in the source tree under the folder &lt;code&gt;runtime&lt;/code&gt;. To link you will need to compile and link the file &lt;code&gt;vultin.c&lt;/code&gt; which is located in the same place (&lt;a href=&#34;https://github.com/modlfo/vult/tree/master/runtime&#34;&gt;https://github.com/modlfo/vult/tree/master/runtime&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;One thing to notice is that every function with memory will have as first argument a reference to a value of it&amp;rsquo;s corresponding type. In the above case, the function &lt;code&gt;Filter_lowpass_2x&lt;/code&gt; returns only one value, therefore the C/C++ will return a value. If the functions return more than one value Vult will automatically generate structures for the types. Here are few Vult functions an their corresponding C/C++ functions:&lt;/p&gt;

&lt;div class=&#34;vult_code&#34; id=&#34;tut5-3&#34;&gt;// example.vult
// single value return, no memory
fun foo1(x:real) {
    return x;
}

// single value return, with memory
fun bar1(x:real) {
    mem y = x;
    return x;
}

// multiple value return, no memory
fun foo2(x:real) {
    return x,x;
}

// multiple value return, with memory
fun bar2(x:real) {
    mem y = x;
    return x,x;
}
&lt;/div&gt;

&lt;p&gt;C/C++ declarations of the functions above:&lt;/p&gt;

&lt;div class=&#34;c_code&#34; id=&#34;tut5-4&#34;&gt;
// single value return, no memory
float Example_foo1(float x);

// single value return, with memory
float Example_bar1(Example__ctx_type_1 &amp;_ctx, float x);

// multiple value return, no memory
void Example_foo2(float x, _tuple_real_real &amp;_output_);

// multiple value return, with memory
void Example_bar2(Example__ctx_type_3 &amp;_ctx, float x,
   _tuple_real_real &amp;_output_);
&lt;/div&gt;

&lt;p&gt;In the examples above you can see that Vult adds an extra argument at the end that is used to return multiple values.&lt;/p&gt;

&lt;h2 id=&#34;generating-fixed-point-code&#34;&gt;Generating fixed-point code&lt;/h2&gt;

&lt;p&gt;When generating C/C++ code Vult by default uses floating point arithmetic (&lt;code&gt;float&lt;/code&gt; numbers). Floating point code is very efficient in big processors like the x86. However when compiled to small microcontrollers (like the ones found in Arduinos or some ARM processors) the code can be very inefficient because these processors do not have a dedicated floating point arithmetic unit.&lt;/p&gt;

&lt;p&gt;Alternatively, fixed-point calculations can be used to perform computations with decimals (like &lt;code&gt;2.0*1.5&lt;/code&gt;). Fixed-point arithmetic encodes the decimal numbers as integers and uses the integer arithmetic unit in small processors to perform calculations (&lt;a href=&#34;https://en.wikipedia.org/wiki/Fixed-point_arithmetic&#34;&gt;https://en.wikipedia.org/wiki/Fixed-point_arithmetic&lt;/a&gt;). The result is that the operations can be performed efficiently at the expense of numeric precision.&lt;/p&gt;

&lt;p&gt;Vult can generate all operations with real numbers as fixed-point with the format q16.16. This means that 16 bits a used to represent integers and 16 bits for decimals. This implies that the largest number that can be represented is &lt;code&gt;32767.0&lt;/code&gt; and the smallest &lt;code&gt;0.0000152588&lt;/code&gt; (the values are signed). Therefore, when generating code with fixed-point numbers one needs to be careful of not going beyond this numbers.&lt;/p&gt;

&lt;p&gt;To generate code with fixed-point numbers we need to call Vult as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./vultc.native -ccode -real fixed filter.vult -o filter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will generate use the type &lt;code&gt;fix16_t&lt;/code&gt; instead of &lt;code&gt;float&lt;/code&gt;. For example, the declaration of the function &lt;code&gt;lowpass_2x&lt;/code&gt; changes to:&lt;/p&gt;

&lt;div class=&#34;c_code&#34; id=&#34;tut5-5&#34;&gt;
fix16_t Filter_lowpass_2x(Filter__ctx_type_3 &amp;_ctx, fix16_t x,
                          fix16_t w0, fix16_t q);
&lt;/div&gt;

&lt;p&gt;The file &lt;code&gt;vultin.h&lt;/code&gt; provides functions to convert among &lt;code&gt;float&lt;/code&gt; &lt;code&gt;fix16_t&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; values.&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/external/ace/ace.js&#34;&gt;&lt;/script&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;../../javascripts/main.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>