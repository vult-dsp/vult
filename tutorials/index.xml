<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Vult Language</title>
    <link>https://vult-dsp.github.io/vult/tutorials/</link>
    <description>Recent content in Tutorials on Vult Language</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Dec 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://vult-dsp.github.io/vult/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vult Language Basics</title>
      <link>https://vult-dsp.github.io/vult/tutorials/basics/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/basics/</guid>
      <description>Vult has syntax that may resemble languages like C/C++, Python or JavaScript. In order to declare a function you can use the keyword fun as follows:&#xA;fun foo() return 0; This functions takes no arguments and returns the integer value zero. If you have more than one statement you can use the curly braces {} to delimit the function body.&#xA;fun foo(x) { val y = 1 + x; return y; } As you may have seen, you can declare variables with the keyword val.</description>
    </item>
    <item>
      <title>Functions with Memory</title>
      <link>https://vult-dsp.github.io/vult/tutorials/functions/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/functions/</guid>
      <description>Vult has two types of functions: passive and active. Passive functions are like the examples that we saw in the Vult Language Basics, for example:&#xA;fun square(x) { return x * x; } These functions simply receive arguments, perform computations and return a value.&#xA;One of the most useful features of Vult are the active functions. These functions have the characteristic that have internal and independent memory variables. The memory variables are declared with the keyword mem.</description>
    </item>
    <item>
      <title>Easy DSP with Vult</title>
      <link>https://vult-dsp.github.io/vult/tutorials/dsp/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/dsp/</guid>
      <description>Functions with memory simplify writing Digital Signal Processing (DSP) code since a mem variable can be used to as a single sample delay z^1. I order to implement the Digital Biquad Filter (direct form 2) we can take the equations directly from Wikipedia: https://en.wikipedia.org/wiki/Digital_biquad_filter.&#xA;We can see the architecture and the equations here:&#xA;We can implement these equations in Vult as follows.&#xA;fun biquad(x0, b0, b1, b2 ,a1 ,a2) : real { mem w1, w2; val w0 = x0 - a1*w1 - a2*w2; val y0 = b0*w0 + b1*w1 + b2*w2; w2, w1 = w1, w0; return y0; } The variables w1 and w2 represent the terms w[n-1] and w[n-2].</description>
    </item>
    <item>
      <title>Oversampling</title>
      <link>https://vult-dsp.github.io/vult/tutorials/oversampling/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/oversampling/</guid>
      <description>One common technique in Digital Signal Processing is Oversampling. Oversampling is often necessary when modeling filters that come from electric circuits or that present nonlinearities or that can become unstable for certain parameters.&#xA;In order to oversample a filter we need for every sample perform N steps. I a language like Vult, that hides the internal memory of a function, oversampling may seem not very obvious.&#xA;In order to perform oversampling, we are gonna use a feature of Vult that allow us to name and reuse the memory created by a function.</description>
    </item>
    <item>
      <title>Generating C/C&#43;&#43;</title>
      <link>https://vult-dsp.github.io/vult/tutorials/generate-c/</link>
      <pubDate>Tue, 12 Jul 2016 21:24:58 +0200</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/generate-c/</guid>
      <description>Once we have some Vult code written it&amp;rsquo;s time to generate some C/C++ code and run it on a target.&#xA;If you have followed the installation steps show in https://github.com/vult-dsp/vult you will have an executable called vultc (if you compiled it by yourself it will be vultc.native or vultc.byte). This is a simple command line application that we will use to generate the code.&#xA;Here is the full code of the oversampled lowpass filter which we are gonna save in a file called filter.</description>
    </item>
    <item>
      <title>Common patterns</title>
      <link>https://vult-dsp.github.io/vult/tutorials/patterns/</link>
      <pubDate>Fri, 01 Jul 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/patterns/</guid>
      <description>Generally, when working with the Vult language, there isn&amp;rsquo;t a strict rule on how to integrate the generated code into your project. However, there are some patterns that I&amp;rsquo;ve found to be particularly useful, depending on the nature of your project. Let me walk you through a few of these strategies.&#xA;NOTE: I have not compiled all the code shown here, so there may be typos&#xA;Audio plugins When crafting an audio plugin, there&amp;rsquo;s typically a primary processing function responsible for rendering the audio.</description>
    </item>
    <item>
      <title>Fixed point computations</title>
      <link>https://vult-dsp.github.io/vult/tutorials/fixed-point/</link>
      <pubDate>Wed, 01 Jun 2016 00:00:00 +0000</pubDate>
      <guid>https://vult-dsp.github.io/vult/tutorials/fixed-point/</guid>
      <description>The Vult language has support for performing fixed-point arithmetics https://en.wikipedia.org/wiki/Fixed-point_arithmetic&#xA;By default, number representations consist of 16 bits for the decimal part and 16 bits for the integer part. The smallest absolute number that can be represented is 0.0000152588, while the largest is approximately 32768.&#xA;Fixed-point numbers prove highly beneficial in microcontrollers lacking a floating-point arithmetic unit, such as Arduino or Raspberry Pi Pico boards. When utilizing fixed-point numbers, the processor conducts computations using integers instead of floating-point numbers, often resulting in increased speed.</description>
    </item>
  </channel>
</rss>
